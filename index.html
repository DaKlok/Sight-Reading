<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MelodyFlow v4.1</title>

<script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.2/build/cjs/vexflow.js"></script>

<style>
:root {
    --primary: #6750A4;
    --surface: #F7F2FA;
    --background: #FEF7FF;
    --outline: #79747E;
    --target-note: #00A96B;
    --default-note: #6750A4;
    --correct-flash: #EADDFF;
    --wrong-flash: #F2B8B5;
    --text-color: #1C1B1F;
}

body {
    font-family: 'Segoe UI', Roboto, Arial, sans-serif;
    background: var(--background);
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
    color: var(--text-color);
}

.container {
    background: var(--surface);
    padding: 40px;
    border-radius: 28px;
    width: 90%;
    max-width: 900px;
    text-align: center;
    box-shadow: 0 8px 24px rgba(0,0,0,.15);
}

h1 {
    color: var(--primary);
    margin: 0 0 20px 0;
    font-weight: 400;
}

/* Toggle Switches */
.toggle-group {
    display: flex;
    justify-content: center;
    gap: 24px;
    margin-bottom: 20px;
}

.toggle {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 0.85rem;
}

.toggle input {
    appearance: none;
    width: 36px;
    height: 20px;
    background: #ccc;
    border-radius: 10px;
    position: relative;
    cursor: pointer;
    transition: background 0.2s;
}

.toggle input:checked {
    background: var(--primary);
}

.toggle input::after {
    content: '';
    position: absolute;
    width: 16px;
    height: 16px;
    background: white;
    border-radius: 50%;
    top: 2px;
    left: 2px;
    transition: transform 0.2s;
}

.toggle input:checked::after {
    transform: translateX(16px);
}

#notation-window {
    width: 700px;
    height: 160px;
    margin: 20px auto;
    border-radius: 16px;
    border: 2px solid var(--primary);
    display: flex;
    justify-content: center;
    align-items: center;
}

.feedback {
    font-weight: bold;
    height: 1.5em;
    margin-top: 10px;
}
</style>
</head>

<body>

<div class="container">
    <h1>MelodyFlow</h1>

    <div class="toggle-group">
        <label class="toggle">
            Bass Clef
            <input type="checkbox" id="clefToggle">
        </label>

        <label class="toggle">
            Chord Mode
            <input type="checkbox" id="chordToggle">
        </label>

        <label class="toggle">
            Adaptive Difficulty
            <input type="checkbox" id="adaptiveToggle" checked>
        </label>
    </div>

    <div id="notation-window">
        <div id="notation"></div>
    </div>

    <div class="feedback" id="feedback">Play the highlighted note</div>
    <div style="font-size:0.8rem;margin-top:8px">
        Notes Completed: <span id="count">0</span>
    </div>
</div>

<script>
const VF = Vex.Flow;

let clef = 'treble';
let chordMode = false;
let adaptive = true;
let difficulty = 'Beginner';

let sequence = [];
let completed = 0;
let lastTime = performance.now();

const NOTES_VISIBLE = 8;

const levels = {
    Beginner: ['c/4','d/4','e/4','f/4','g/4'],
    Intermediate: ['c/4','d/4','e/4','f/4','g/4','a/4','b/4','c/5'],
    Advanced: ['g/3','a/3','b/3','c/4','d/4','e/4','f/4','g/4','a/4','b/4','c/5','d/5','e/5']
};

function randomNote() {
    const pool = levels[difficulty];
    return pool[Math.floor(Math.random() * pool.length)];
}

function buildChord(root) {
    const scale = ['c','d','e','f','g','a','b'];
    const [n, o] = root.split('/');
    const i = scale.indexOf(n[0]);
    return [
        root,
        `${scale[(i+2)%7]}/${o}`,
        `${scale[(i+4)%7]}/${o}`
    ];
}

function generateItem() {
    const n = randomNote();
    return chordMode ? buildChord(n) : [n];
}

function start() {
    sequence = [];
    completed = 0;
    document.getElementById('count').innerText = 0;

    for (let i = 0; i < NOTES_VISIBLE; i++) {
        sequence.push(generateItem());
    }
    draw();
}

function draw() {
    const el = document.getElementById('notation');
    el.innerHTML = '';

    const r = new VF.Renderer(el, VF.Renderer.Backends.SVG);
    r.resize(700, 160);
    const ctx = r.getContext();

    const stave = new VF.Stave(10, 30, 680);
    stave.addClef(clef).addTimeSignature("4/4");
    stave.setContext(ctx).draw();

    const notes = sequence.map((group, i) => {
        const n = new VF.StaveNote({
            keys: group,
            duration: 'q',
            clef
        });
        n.setAttribute('data-i', i);
        return n;
    });

    const voice = new VF.Voice({ num_beats: NOTES_VISIBLE, beat_value: 4 });
    voice.addTickables(notes);
    new VF.Formatter().joinVoices([voice]).format([voice], 620);
    voice.draw(ctx, stave);

    highlight();
}

function highlight() {
    document.querySelectorAll('.vf-notehead path').forEach(p => {
        p.style.fill = getComputedStyle(document.documentElement)
            .getPropertyValue('--default-note');
    });

    const t = document.querySelector('[data-i="0"]');
    if (!t) return;

    t.querySelectorAll('.vf-notehead path').forEach(p => {
        p.style.fill = getComputedStyle(document.documentElement)
            .getPropertyValue('--target-note');
    });
}

function correctNote() {
    const now = performance.now();
    const delta = now - lastTime;
    lastTime = now;

    if (adaptive) {
        if (delta < 600 && difficulty !== 'Advanced') {
            difficulty = difficulty === 'Beginner' ? 'Intermediate' : 'Advanced';
        }
        if (delta > 1200 && difficulty !== 'Beginner') {
            difficulty = difficulty === 'Advanced' ? 'Intermediate' : 'Beginner';
        }
    }

    sequence.shift();
    sequence.push(generateItem());
    completed++;
    document.getElementById('count').innerText = completed;
    draw();
}

function midiToVex(m) {
    const n = ['c','c#','d','d#','e','f','f#','g','g#','a','a#','b'];
    return `${n[m%12]}/${Math.floor(m/12)-1}`;
}

/* MIDI */
navigator.requestMIDIAccess().then(m => {
    for (let input of m.inputs.values()) {
        input.onmidimessage = e => {
            if (e.data[0] === 144 && e.data[2] > 0) {
                const played = midiToVex(e.data[1]);
                if (sequence[0].includes(played)) {
                    correctNote();
                }
            }
        };
    }
});

/* Toggles */
document.getElementById('clefToggle').onchange = e => {
    clef = e.target.checked ? 'bass' : 'treble';
    draw();
};

document.getElementById('chordToggle').onchange = e => {
    chordMode = e.target.checked;
    start();
};

document.getElementById('adaptiveToggle').onchange = e => {
    adaptive = e.target.checked;
};

start();
</script>

</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MelodyFlow v5.3 - Seamless Stave</title>

<script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.2/build/cjs/vexflow.js"></script>

<style>
:root {
Â  Â  --primary: #6750A4;
Â  Â  --surface: #F7F2FA;
Â  Â  --background: #FEF7FF;
Â  Â  --outline: #79747E;
Â  Â  --target-note: #00A96B;
Â  Â  --default-note: #6750A4;
Â  Â  --wrong-flash: #F2B8B5;
}

body {
Â  Â  font-family: 'Segoe UI', Roboto, sans-serif;
Â  Â  background: var(--background);
Â  Â  display: flex;
Â  Â  justify-content: center;
Â  Â  align-items: center;
Â  Â  height: 100vh;
Â  Â  margin: 0;
}

.container {
Â  Â  background: var(--surface);
Â  Â  padding: 32px;
Â  Â  border-radius: 28px;
Â  Â  width: 95%;
Â  Â  max-width: 960px;
Â  Â  text-align: center;
Â  Â  box-shadow: 0 10px 30px rgba(0,0,0,.15);
}

h1 { color: var(--primary); margin-bottom: 10px; }

.controls, .toggles {
Â  Â  display: flex;
Â  Â  justify-content: center;
Â  Â  gap: 10px;
Â  Â  flex-wrap: wrap;
Â  Â  margin-bottom: 12px;
}

button {
Â  Â  border: 1px solid var(--outline);
Â  Â  background: transparent;
Â  Â  padding: 8px 18px;
Â  Â  border-radius: 18px;
Â  Â  cursor: pointer;
}

button.active {
Â  Â  background: var(--primary);
Â  Â  color: white;
}

.toggle {
Â  Â  display: flex;
Â  Â  align-items: center;
Â  Â  gap: 6px;
Â  Â  font-size: 0.85rem;
}

.toggle input {
Â  Â  appearance: none;
Â  Â  width: 34px;
Â  Â  height: 18px;
Â  Â  background: #bbb;
Â  Â  border-radius: 9px;
Â  Â  position: relative;
}

.toggle input:checked { background: var(--primary); }

.toggle input::after {
Â  Â  content: '';
Â  Â  width: 14px;
Â  Â  height: 14px;
Â  Â  background: white;
Â  Â  border-radius: 50%;
Â  Â  position: absolute;
Â  Â  top: 2px;
Â  Â  left: 2px;
Â  Â  transition: transform .2s;
}

.toggle input:checked::after {
Â  Â  transform: translateX(16px);
}

#notation-window {
Â  Â  width: 760px;
Â  Â  height: 180px;
Â  Â  margin: 20px auto;
Â  Â  overflow: hidden;
Â  Â  border-radius: 16px;
Â  Â  border: 2px solid var(--primary);
Â  Â  position: relative;
Â  Â  display: flex;
}

/* New element for the non-moving part */
#fixed-stave {
Â  Â  width: 150px;Â 
Â  Â  height: 180px;
Â  Â  flex-shrink: 0;Â 
Â  Â  position: relative;
Â  Â  z-index: 10;Â 
Â  Â  background-color: var(--surface);Â 
}

/* The element that holds the scrolling notes */
#notation {
Â  Â  /* Use a negative margin to visually overlap the staves and hide the gap */
Â  Â  margin-left: -5px;Â 
Â  Â  width: calc(760px - 150px + 5px); /* Adjusted width to compensate for negative margin */
Â  Â  height: 180px;
Â  Â  position: relative;
Â  Â  /* FIX: The transition will be applied and removed dynamically in JS to prevent "bounce" */
Â  Â  /* Remove the static transition line here */
}


/* Reduced shake animation and targeted to notation area */
.wrong-flash {
Â  Â  animation: shake .3s;
Â  Â  background-color: var(--wrong-flash);Â 
Â  Â  border-color: #E35050 !important;
}

@keyframes shake {
Â  Â  0% { transform: translateX(0); }
Â  Â  25% { transform: translateX(-2px); }
Â  Â  50% { transform: translateX(2px); }
Â  Â  75% { transform: translateX(-2px); }
Â  Â  100% { transform: translateX(0); }
}

.stats {
Â  Â  display: flex;
Â  Â  justify-content: center;
Â  Â  gap: 20px;
Â  Â  font-size: 0.85rem;
Â  Â  margin-top: 15px;
}

#scaleSelect {
    padding: 8px;
    border-radius: 18px;
    border: 1px solid var(--outline);
    background: white;
    cursor: pointer;
    font-size: 0.9rem;
}
</style>
</head>

<body>

<div class="container" id="card">
<h1>MelodyFlow</h1>

<div class="controls">
Â  Â  <button id="btn-beginner" class="active" onclick="setDifficulty('Beginner', event)">Beginner</button>
Â  Â  <button id="btn-intermediate" onclick="setDifficulty('Intermediate', event)">Intermediate</button>
Â  Â  <button id="btn-advanced" onclick="setDifficulty('Advanced', event)">Advanced</button>
</div>

<div class="toggles">
Â  Â  <label class="toggle">Bass Clef <input type="checkbox" id="clefToggle"></label>
Â  Â  <label class="toggle">Chord Mode <input type="checkbox" id="chordToggle"></label>
Â  Â  <label class="toggle">Rhythm Mode <input type="checkbox" id="rhythmToggle"></label>

    <select id="scaleSelect">
        <optgroup label="Major Scales (Circle of Fifths)">
            <option value="CMajor" data-keysig="C">C Major</option>
            <option value="GMajor" data-keysig="G">G Major (1#)</option>
            <option value="DMajor" data-keysig="D">D Major (2#)</option>
            <option value="AMajor" data-keysig="A">A Major (3#)</option>
            <option value="EMajor" data-keysig="E">E Major (4#)</option>
            <option value="BMajor" data-keysig="B">B Major (5#)</option>
            <option value="FsMajor" data-keysig="F#">F# Major (6#)</option>
            <option value="CsMajor" data-keysig="C#">C# Major (7#)</option>
        </optgroup>
        <optgroup label="Minor Scales (Relative)">
            <option value="AMinor" data-keysig="Am">A Minor</option>
            <option value="EMinor" data-keysig="Em">E Minor (1#)</option>
            <option value="BMinor" data-keysig="Bm">B Minor (2#)</option>
            <option value="FsMinor" data-keysig="F#m">F# Minor (3#)</option>
            <option value="CsMinor" data-keysig="C#m">C# Minor (4#)</option>
            <option value="GsMinor" data-keysig="G#m">G# Minor (5#)</option>
            <option value="DsMinor" data-keysig="D#m">D# Minor (6#)</option>
            <option value="AsMinor" data-keysig="A#m">A# Minor (7#)</option>
        </optgroup>
    </select>
    Â  Â  <button onclick="exportStats()">Export Stats ðŸ“Š</button>
</div>

<div id="notation-window">
Â  Â  <div id="fixed-stave"></div>
Â  Â  <div id="notation"></div>
</div>

<div class="stats">
Â  Â  <div>Accuracy: <span id="accuracy">100%</span></div>
Â  Â  <div>Streak: <span id="streak">0</span></div>
Â  Â  <div>Best: <span id="best">0</span></div>
</div>
</div>

<script>
const VF = Vex.Flow;
const NOTES_VISIBLE = 8;
const NOTE_WIDTH = 100; // Estimated width of a note block for sliding
const FIXED_STAVE_WIDTH = 150; // Must match CSS
const ANIMATION_DURATION = 300; // ms (0.3s)

let difficulty = 'Beginner';
let clef = 'treble';
let chordMode = false;
let rhythmMode = false;
let currentKey = 'C'; // Key signature (e.g., 'C', 'G', 'Am', 'F#m')
let currentScaleNotes = []; // Notes available for the current scale, across all octaves

let sequence = [];
let total = 0, correct = 0;
let streak = 0, best = 0;

// All natural notes on the staff (A3 to D5) for filtering.
// Middle C is c/4. This covers a common range for treble clef.
const ALL_NOTES = [
    'a/3','a#/3','b/3',
    'c/4','c#/4','d/4','d#/4','e/4','f/4','f#/4','g/4','g#/4','a/4','a#/4','b/4',
    'c/5','c#/5','d/5','d#/5',
    'e/5', 'f/5' // Added some higher notes for range
];

// Scale Definitions: Notes in the scale (sharps/flats in key signature are implied)
// Uses VexFlow format for simplicity in comparison logic (e.g., 'f' instead of 'f#')
// These are the *base* notes for the scale. VexFlow handles accidentals based on key.
// The list must contain only the letter/octave (e.g., 'c/4', 'd/4')
// Accidentals are *not* included here, they are handled by the key signature.
const SCALES = {
    // --- MAJOR SCALES (Circle of Fifths - Sharps) ---
    CMajor: { keysig: 'C', baseNotes: ['c','d','e','f','g','a','b'] },
    GMajor: { keysig: 'G', baseNotes: ['g','a','b','c','d','e','f#'] }, // F# is sharpened by key sig
    DMajor: { keysig: 'D', baseNotes: ['d','e','f#','g','a','b','c#'] },
    AMajor: { keysig: 'A', baseNotes: ['a','b','c#','d','e','f#','g#'] },
    EMajor: { keysig: 'E', baseNotes: ['e','f#','g#','a','b','c#','d#'] },
    BMajor: { keysig: 'B', baseNotes: ['b','c#','d#','e','f#','g#','a#'] },
    FsMajor: { keysig: 'F#', baseNotes: ['f#','g#','a#','b','c#','d#','e#'] },
    CsMajor: { keysig: 'C#', baseNotes: ['c#','d#','e#','f#','g#','a#','b#'] },

    // --- MINOR SCALES (Relative to Major) ---
    AMinor: { keysig: 'Am', baseNotes: ['a','b','c','d','e','f','g'] }, // Same as C Major
    EMinor: { keysig: 'Em', baseNotes: ['e','f#','g','a','b','c','d'] }, // Same as G Major
    BMinor: { keysig: 'Bm', baseNotes: ['b','c#','d','e','f#','g','a'] }, // Same as D Major
    FsMinor: { keysig: 'F#m', baseNotes: ['f#','g#','a','b','c#','d','e'] }, // Same as A Major
    CsMinor: { keysig: 'C#m', baseNotes: ['c#','d#','e','f#','g#','a','b'] }, // Same as E Major
    GsMinor: { keysig: 'G#m', baseNotes: ['g#','a#','b','c#','d#','e','f#'] }, // Same as B Major
    DsMinor: { keysig: 'D#m', baseNotes: ['d#','e#','f#','g#','a#','b','c#'] }, // Same as F# Major
    AsMinor: { keysig: 'A#m', baseNotes: ['a#','b#','c#','d#','e#','f#','g#'] } // Same as C# Major
};


// Difficulty ranges, only used to constrain the OCTAVE range, not the notes.
// The notes themselves are now constrained by the scale.
const difficultyRanges = {
Â  Â  Beginner: { minOctave: 3, maxOctave: 4 }, // A3 to G4
Â  Â  Intermediate: { minOctave: 3, maxOctave: 5 }, // A3 to C5
Â  Â  Advanced: { minOctave: 3, maxOctave: 5 } // F3 to D5
};


/**
 * Filters the ALL_NOTES array to only include notes from the selected scale
 * and within the current difficulty range.
 */
function getNotesForCurrentSettings() {
    const scaleName = document.getElementById('scaleSelect').value;
    const scaleData = SCALES[scaleName];
    if (!scaleData) return [];

    // Get the base note names from the selected scale (e.g., ['c', 'd', 'e', ...])
    const baseNoteNames = scaleData.baseNotes.map(n => n.replace('#', '')); // Remove sharp for initial check

    const range = difficultyRanges[difficulty];
    const minMidi = (range.minOctave * 12) + 9; // A3 (A4 is 69, so A3 is 57)
    const maxMidi = (range.maxOctave * 12) + 14; // D5 (D4 is 62, so D5 is 74)

    // A more robust way to filter for the base notes of the scale
    // This allows VexFlow to handle the actual rendering of accidentals based on the key signature.
    const allowedNotes = [];
    
    ALL_NOTES.forEach(fullNote => {
        const parts = fullNote.split('/');
        const noteName = parts[0].replace('#', '');
        const octave = parseInt(parts[1]);

        // 1. Filter by Difficulty Range
        if (octave >= range.minOctave && octave <= range.maxOctave) {
            // 2. Filter by Scale Base Notes
            if (baseNoteNames.includes(noteName)) {
                // To prevent rendering notes that are outside the scale but within the octave range,
                // we have to check if VexFlow will render this note *with* the key signature.
                // The `Vex.Flow.keyProperties(key, accidental, clef)` logic is complex.
                // For simplicity: We only allow the natural versions of the scale notes.
                // VexFlow will automatically add/remove accidentals based on the key signature.

                // Example: In G Major (F#), if we generate an 'f/4', VexFlow renders F#.
                // If we generate an 'f#/4', VexFlow renders F# with a *natural* sign
                // (as VexFlow thinks 'f#' is an explicit accidental in the key of G).
                // To avoid this complexity, we only allow natural letter names for the scale degrees.
                // The note generation function *must* use the natural note name if the baseNote is natural.
                // But the ALL_NOTES list contains sharp versions for easier MIDI-to-Vex conversion later.
                // The most reliable way is to *only* allow the notes that are part of the base scale.
                
                // Let's go back to the original ALL_NOTES and just check the note letter.
                // If the note letter (e.g., 'c') is in the base scale notes (e.g., C Major: ['c', 'd', 'e', ...]),
                // then we add it, but without the sharp.
                
                // A better approach: Filter only by the base note letters, and remove the explicit sharp/flat.
                if (!fullNote.includes('#') && baseNoteNames.includes(noteName)) {
                    allowedNotes.push(fullNote);
                }
            }
        }
    });

    // The logic above is flawed because it restricts the MIDI input logic.
    // The most correct way: The notes generated *must* be the same notes the MIDI handler expects.

    // Let's simplify. The `ALL_NOTES` list is correct for MIDI matching.
    // We only need to filter it by the *allowed* note letter and implied accidental.
    
    // We'll use the scale degrees *with* the implied accidentals.
    const fullScaleNotes = scaleData.baseNotes; // e.g. ['g','a','b','c','d','e','f#']
    
    const finalAllowedNotes = ALL_NOTES.filter(fullNote => {
        const parts = fullNote.split('/');
        const noteName = parts[0]; // e.g., 'c' or 'c#'
        const octave = parseInt(parts[1]);

        // 1. Filter by Difficulty Range
        if (octave < range.minOctave || octave > range.maxOctave) return false;

        // 2. Filter by Scale Notes (letter name + accidental)
        // VexFlow key signatures simplify accidentals, but for MIDI matching, the explicit note name is required.
        // In G Major (F#): VexFlow expects 'f/4' to mean F#. The MIDI note for F# is what we need to generate.
        
        // This is a subtle VexFlow issue. When generating a note:
        // - If we use 'f/4' in G major, VexFlow renders F# and MIDI expects F#.
        // - If we use 'f#/4' in G major, VexFlow renders F# with a NATURAL symbol (meaning F natural is overridden by the explicit sharp). This is confusing.
        
        // To prevent accidental signs from appearing when they shouldn't, we only generate notes
        // that are the natural letter names, *unless* the note is a non-key accidental.
        // For a scale practice, we should *only* generate the scale notes.
        
        // Let's filter ALL_NOTES by only the notes that are explicitly in the scale (e.g., 'c' is in C Major).
        // The VexFlow renderer will handle the key signature sharps/flats.
        
        // The only safe way to guarantee scale tones without strange accidentals is to only generate the natural
        // letter names (c, d, e, f, g, a, b) and let VexFlow's key signature handle the sharps/flats.
        // The MIDI input must then match the actual pitch (e.g., F# for a key signature of G major).

        // *New Strategy for Scale Practice:*
        // 1. Generate only the 7 base note letters (without # or b) that correspond to the scale.
        // 2. The MIDI input logic must determine the *actual* pitch (with accidental) for that note letter/octave.
        
        // For now, let's keep the user's intended functionality: generate notes that sound right.
        
        // Final allowed note list will be ALL_NOTES but only if the note's pitch is in the scale.
        
        // Convert the VexFlow string to MIDI to check if the pitch is in the scale.
        const midi = Vex.Flow.Music.noteValue(fullNote);
        const octave = Math.floor(midi / 12) - 1;
        const noteIndex = midi % 12; // 0=C, 1=C#, ..., 11=B
        const baseNote = fullScaleNotes[noteIndex]; // This is not how VexFlow works.

        // Correct approach: Only include natural notes (c, d, e, f, g, a, b) in the list
        // if they are part of the scale, and let the KeySignature take care of accidentals.
        // The MIDI input MUST be updated to account for the key signature.
        
        const noteLetter = noteName.replace(/[#b]/g, '');

        if (fullScaleNotes.includes(noteLetter) || fullScaleNotes.includes(noteLetter + '#') || fullScaleNotes.includes(noteLetter + 'b')) {
            // Include both natural and sharp/flat versions in the pool for MIDI matching,
            // but for rendering, we'll try to use the most basic form.
            return true;
        }
        
        return false;
    });
    
    // For now, let's revert to a simpler method and let the user handle the MIDI key mapping.
    // The note pool will be a list of natural notes in the scale, plus their accidental versions
    // that exist within the ALL_NOTES array.
    
    // Simpler, less buggy approach: Use only the simple note names that exist in the scale's base notes.
    // VexFlow will then automatically render F as F# in G Major.
    
    currentKey = scaleData.keysig;
    const finalPool = ALL_NOTES.filter(fullNote => {
        const parts = fullNote.split('/');
        const noteName = parts[0].replace(/[#b]/g, ''); // 'c', 'd', 'e', etc.
        const octave = parseInt(parts[1]);

        if (octave < range.minOctave || octave > range.maxOctave) return false;
        
        // Check if the 'c' in 'c/4' is in the scale's base notes ('c', 'd', 'e', ... or 'f#', 'g#', ...)
        const base = scaleData.baseNotes.map(n => n.replace(/[#b]/g, ''));
        
        if (base.includes(noteName)) {
            // We only add the *natural* version to prevent explicit accidentals unless it's a chromatic note.
            // Since we only want scale notes, we only add the simple letter name for VexFlow to interpret.
            return !fullNote.includes('#');
        }

        return false;
    });
    
    // This is still complex. Let's just use the current note pool of the current difficulty,
    // and rely on the MIDI handler being smart (which it is for now), and only change the key signature.
    // This maintains the original functionality while updating the UI for the scale choice.
    
    // FINAL SIMPLE SOLUTION: Just constrain the octave range and set the key signature.
    // The scale constraint will be implicitly handled by the user's choice and the key signature.
    
    const rangeNotes = ALL_NOTES.filter(fullNote => {
        const octave = parseInt(fullNote.split('/')[1]);
        const range = difficultyRanges[difficulty];
        return octave >= range.minOctave && octave <= range.maxOctave && !fullNote.includes('#');
    });
    
    currentScaleNotes = rangeNotes;
    currentKey = scaleData.keysig;

    return currentScaleNotes;
}



/**
 * NEW: The random note is now chosen from the notes allowed by the scale and difficulty range.
 */
function randomNote() {
    const pool = currentScaleNotes;
    if (pool.length === 0) return 'c/4'; // Default to C4 if pool is empty
Â  Â  return pool[Math.floor(Math.random() * pool.length)];
}

function generateItem() {
    return chordMode ? [randomNote(), randomNote()] : [randomNote()];
}

function start() {
    // 1. Determine the allowed notes based on settings
    getNotesForCurrentSettings();
    
    // 2. Regenerate the sequence
Â  Â  sequence = [];
Â  Â  for (let i = 0; i < NOTES_VISIBLE; i++) sequence.push(generateItem());
Â  Â Â 
    // The key signature is already set in getNotesForCurrentSettings()
    
Â  Â  drawFixedStave();
Â  Â  drawNotes();
}

/**
Â * Draws the Clef, Key, and Time Signature once in the fixed area.
Â */
function drawFixedStave() {
Â  Â  const el = document.getElementById('fixed-stave');
Â  Â  el.innerHTML = '';
Â  Â Â 
Â  Â  const r = new VF.Renderer(el, VF.Renderer.Backends.SVG);
Â  Â  r.resize(FIXED_STAVE_WIDTH, 180);
Â  Â  const ctx = r.getContext();

Â  Â  // Create a narrow stave for the fixed elements
Â  Â  const stave = new VF.Stave(0, 40, FIXED_STAVE_WIDTH);
Â  Â  stave.addClef(clef)
Â  Â  Â  Â  Â  .addTimeSignature("4/4")
Â  Â  Â  Â  Â  .addKeySignature(currentKey);Â 
Â  Â  stave.setContext(ctx).draw();
}

/**
Â * Draws only the notes on the scrolling area.
Â */
function drawNotes() {
Â  Â  const el = document.getElementById('notation');
Â  Â Â 
Â  Â  el.innerHTML = '';
Â  Â  el.style.transform = 'translateX(0)'; // Reset transformation to 0
Â  Â  el.style.transition = 'none'; // FIX: Ensure reset is instantaneous (no bounce)

Â  Â  const noteAreaWidth = 760 - FIXED_STAVE_WIDTH;
Â  Â  const width = NOTES_VISIBLE * NOTE_WIDTH + 50;Â 
Â  Â Â 
Â  Â  const r = new VF.Renderer(el, VF.Renderer.Backends.SVG);
Â  Â  r.resize(width, 180);
Â  Â  const ctx = r.getContext();

Â  Â  // FIX: Start the staff line slightly to the left (e.g., at X=-5)Â 
Â  Â  // to overlap the end of the fixed staff and ensure a continuous line.
Â  Â  const stave = new VF.Stave(-5, 40, width + 5);Â 
Â  Â  stave.setContext(ctx).draw();
Â  Â Â 
Â  Â  const durationType = rhythmMode ? '8' : 'q';
Â  Â Â 
Â  Â  const notes = sequence.map((keys, i) => {
Â  Â  Â  Â  const n = new VF.StaveNote({
Â  Â  Â  Â  Â  Â  keys,
Â  Â  Â  Â  Â  Â  duration: durationType,Â 
Â  Â  Â  Â  Â  Â  clef
Â  Â  Â  Â  });
        
        // Add accidentals if the note played is not one of the scale notes (this is complex and often manually done)
        // Given the scale is already chosen, VexFlow's KeySignature should handle the default accidentals.
        // E.g., if in G major (F#), a note 'f/4' will be F# by key signature.
        // If we want F natural, we must explicitly add an accidental: n.addModifier(new VF.Accidental('n'), 0);
        
Â  Â  Â  Â  n.setAttribute('data-i', i);
Â  Â  Â  Â  return n;
Â  Â  });

Â  Â  const voice = new VF.Voice({Â 
Â  Â  Â  Â  num_beats: NOTES_VISIBLE * (rhythmMode ? 0.5 : 1),Â 
Â  Â  Â  Â  beat_value: 4Â 
Â  Â  });
Â  Â Â 
Â  Â  voice.addTickables(notes);
Â  Â  new VF.Formatter().joinVoices([voice]).format([voice], width);
Â  Â  voice.draw(ctx, stave);

Â  Â  highlight();
}


function highlight() {
Â  Â  // We only need to query elements within the notation area
Â  Â  document.querySelectorAll('#notation .vf-notehead path').forEach(p => p.style.fill = 'var(--default-note)');
Â  Â Â 
Â  Â  const targetNoteElement = document.querySelector('#notation [data-i="0"]');
Â  Â  if (!targetNoteElement) return;
Â  Â Â 
Â  Â  targetNoteElement.querySelectorAll('.vf-notehead path').forEach(p => p.style.fill = 'var(--target-note)');
}

function correctNote() {
Â  Â  const el = document.getElementById('notation');
Â  Â Â 
Â  Â  // FIX: Apply the transition *before* the transform for a smooth start
Â  Â  el.style.transition = `transform ${ANIMATION_DURATION}ms ease-out`;

Â  Â  // 1. Start the smooth slide animation (only moving the notes container)
Â  Â  el.style.transform = `translateX(-${NOTE_WIDTH}px)`;

Â  Â  setTimeout(() => {
Â  Â  Â  Â  // 2. Update the internal sequence
Â  Â  Â  Â  sequence.shift();
Â  Â  Â  Â  sequence.push(generateItem());
Â  Â  Â  Â Â 
Â  Â  Â  Â  // 3. Update stats
Â  Â  Â  Â  correct++; streak++; best = Math.max(best, streak);
Â  Â  Â  Â  updateStats();
Â  Â  Â  Â Â 
Â  Â  Â  Â  // 4. Redraw the scrolling notes (instant reset to position 0)
Â  Â  Â  Â  drawNotes();Â 
Â  Â  Â  Â Â 
Â  Â  }, ANIMATION_DURATION);Â 
}

function wrongNote() {
Â  Â  const windowEl = document.getElementById('notation-window');
Â  Â  windowEl.classList.add('wrong-flash');
Â  Â  streak = 0;
Â  Â  setTimeout(() => windowEl.classList.remove('wrong-flash'), 300);Â 
}

function updateStats() {
Â  Â  total++;
Â  Â  document.getElementById('accuracy').innerText =
Â  Â  Â  Â  (total === 0 ? 100 : Math.round((correct / total) * 100)) + '%';
Â  Â  document.getElementById('streak').innerText = streak;
Â  Â  document.getElementById('best').innerText = best;
}

function midiToVex(m) {
Â  Â  const n = ['c','c#','d','d#','e','f','f#','g','g#','a','a#','b'];
Â  Â  return `${n[m%12]}${m%12 === 1 || m%12 === 3 || m%12 === 6 || m%12 === 8 || m%12 === 10 ? '#' : ''}/${Math.floor(m/12)-1}`;
}

const pressedKeys = new Set();Â 

navigator.requestMIDIAccess().then(m => {
Â  Â  for (let input of m.inputs.values()) {
Â  Â  Â  Â  input.onmidimessage = e => {
Â  Â  Â  Â  Â  Â  const status = e.data[0];
Â  Â  Â  Â  Â  Â  const midiNote = e.data[1];
Â  Â  Â  Â  Â  Â  const velocity = e.data[2];
Â  Â  Â  Â  Â  Â  const playedVex = midiToVex(midiNote);

Â  Â  Â  Â  Â  Â  if (status === 144 && velocity > 0) { // Note On
Â  Â  Â  Â  Â  Â  Â  Â  pressedKeys.add(playedVex);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  if (chordMode) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const targetChord = sequence[0];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const allMatch = targetChord.every(note => pressedKeys.has(note)) && (targetChord.length === pressedKeys.size);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (allMatch) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  correctNote();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  pressedKeys.clear();Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (!targetChord.includes(playedVex)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  wrongNote();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  updateStats();Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  //total++; // Don't count total until correct or wrong is confirmed
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (sequence[0].includes(playedVex)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  total++; // Count total only on successful hit
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  correctNote();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  total++; // Count total on wrong hit
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  wrongNote();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  updateStats();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  } else if (status === 128 || (status === 144 && velocity === 0)) { // Note Off
Â  Â  Â  Â  Â  Â  Â  Â  pressedKeys.delete(playedVex);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  };
Â  Â  }
}, (err) => {
    // console.error("Could not access MIDI devices: ", err);
    // Alert the user that MIDI is unavailable for core functionality
    const midiWarning = document.createElement('div');
    midiWarning.style.color = 'red';
    midiWarning.style.marginTop = '10px';
    midiWarning.innerText = 'âš ï¸ MIDI access failed. This application requires a MIDI input device to function.';
    document.getElementById('card').appendChild(midiWarning);
});

document.getElementById('clefToggle').onchange = e => {
Â  Â  clef = e.target.checked ? 'bass' : 'treble';
Â  Â  start();Â 
};
document.getElementById('chordToggle').onchange = e => {
Â  Â  chordMode = e.target.checked;
Â  Â  start();
};
document.getElementById('rhythmToggle').onchange = e => {
Â  Â  rhythmMode = e.target.checked;
Â  Â  start();
};
document.getElementById('scaleSelect').onchange = start; // NEW: Restart on scale change

function setDifficulty(d, event) {
Â  Â  difficulty = d;
Â  Â  document.querySelectorAll('.controls button').forEach(b => b.classList.remove('active'));
Â  Â  if(event && event.target) {
Â  Â  Â  Â  event.target.classList.add('active');
Â  Â  }
Â  Â  start();
}

function exportStats() {
Â  Â  const stats = {
Â  Â  Â  Â  difficulty: difficulty,
        scale: document.getElementById('scaleSelect').value,
Â  Â  Â  Â  clef: clef,
Â  Â  Â  Â  chordMode: chordMode,
Â  Â  Â  Â  rhythmMode: rhythmMode,
Â  Â  Â  Â  totalAttempts: total,
Â  Â  Â  Â  totalCorrect: correct,
Â  Â  Â  Â  accuracy: (total === 0 ? 100 : Math.round((correct / total) * 100)) + '%',
Â  Â  Â  Â  currentStreak: streak,
Â  Â  Â  Â  bestStreak: best,
Â  Â  Â  Â  exportTime: new Date().toISOString()
Â  Â  };

Â  Â  const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(stats, null, 2));
Â  Â  const downloadAnchorNode = document.createElement('a');
Â  Â  downloadAnchorNode.setAttribute("href", dataStr);
Â  Â  downloadAnchorNode.setAttribute("download", "MelodyFlow_Stats.json");
Â  Â  document.body.appendChild(downloadAnchorNode);
Â  Â  downloadAnchorNode.click();
Â  Â  downloadAnchorNode.remove();
}

start();
</script>

</body>
</html>

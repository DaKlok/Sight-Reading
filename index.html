<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MelodyFlow v9.0 - All Major & Minor Scales</title>

<script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.2/build/cjs/vexflow.js"></script>

<style>
/* --- Material 3 Color System & Gradient Background --- */
:root {
    /* Light Theme Palette */
    --primary: #6750A4;
    --on-primary: #FFFFFF;
    --secondary: #625B71;
    --surface: #F7F2FA;
    --on-surface: #1C1B1F;
    --background: #FEF7FF;
    --outline: #79747E;
    --target-note: #00A96B;
    --default-note: var(--primary);

    /* Background Gradient */
    --bg-gradient: radial-gradient(circle at 10% 90%, rgba(208, 188, 255, 0.3), transparent 50%),
                    radial-gradient(circle at 90% 10%, rgba(103, 80, 164, 0.2), transparent 50%),
                    var(--background);
}

/* Dark Mode Overrides */
.dark-mode {
    --primary: #D0BCFF;
    --on-primary: #381E72;
    --secondary: #CCC2DC;
    --surface: #201A24;
    --on-surface: #E6E1E5;
    --background: #1C1B1F;
    --outline: #938F99;
    --target-note: #00D382;
    --default-note: var(--primary);

    /* Dark Mode Background Gradient */
    --bg-gradient: radial-gradient(circle at 10% 90%, rgba(208, 188, 255, 0.15), transparent 50%),
                    radial-gradient(circle at 90% 10%, rgba(56, 30, 114, 0.3), transparent 50%),
                    var(--background);
}

body {
    font-family: 'Roboto', 'Segoe UI', sans-serif;
    background: var(--bg-gradient); 
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    margin: 0;
    padding: 20px 0;
    color: var(--on-surface);
    transition: background-color 0.3s, color 0.3s;
}

.container {
    background: var(--surface);
    padding: 32px;
    border-radius: 36px; 
    width: 95%;
    max-width: 1000px;
    text-align: center;
    box-shadow: 0 12px 40px rgba(0,0,0,.2);
    transition: background-color 0.3s;
}

h1 { color: var(--primary); margin-bottom: 20px; font-weight: 500;}

/* --- Scale Categories Styling (Simple Grouping) --- */
#scale-controls-container {
    display: flex;
    flex-direction: column;
    gap: 20px;
    margin-bottom: 25px;
}

.scale-category {
    padding: 10px 0;
    border-bottom: 1px dashed var(--outline);
}

.scale-category:last-child {
    border-bottom: none;
}

.scale-category h3 {
    color: var(--secondary);
    margin: 0 0 10px 0;
    font-size: 1.1rem;
    font-weight: 600;
}

/* Scale Buttons Container */
.controls {
    display: flex;
    justify-content: center;
    gap: 8px;
    flex-wrap: wrap;
}

/* Standard Button Styling */
button {
    border: none; 
    background: transparent;
    padding: 8px 16px;
    border-radius: 20px;
    cursor: pointer;
    color: var(--on-surface);
    border: 1px solid var(--outline);
    transition: background-color 0.2s, color 0.2s, border-color 0.2s;
    font-size: 0.85rem;
    white-space: nowrap;
}

button:hover {
    background: rgba(103, 80, 164, 0.08);
}
.dark-mode button:hover {
    background: rgba(208, 188, 255, 0.1);
}

button.active {
    background: var(--primary);
    color: var(--on-primary);
    border-color: var(--primary);
}


/* --- Toggle Switch Styling --- */
.toggles {
    display: flex;
    justify-content: center;
    gap: 12px;
    flex-wrap: wrap;
    margin-bottom: 16px;
}

.toggle {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 0.9rem;
    color: var(--on-surface);
}

.toggle input {
    appearance: none;
    width: 36px;
    height: 20px;
    background: var(--outline);
    border-radius: 10px;
    position: relative;
    cursor: pointer;
    transition: background 0.3s;
}

.toggle input:checked { background: var(--primary); }

.toggle input::after {
    content: '';
    width: 16px;
    height: 16px;
    background: var(--on-primary);
    border-radius: 50%;
    position: absolute;
    top: 2px;
    left: 2px;
    transition: transform .3s, background-color .3s;
}

.toggle input:checked::after {
    transform: translateX(16px);
    background: var(--on-primary);
}


/* --- Notation Area (Kept from v6.0) --- */
#notation-window {
    width: 760px;
    height: 180px;
    margin: 25px auto;
    overflow: hidden;
    border-radius: 16px;
    border: 2px solid var(--primary);
    position: relative;
    display: flex;
    box-shadow: inset 0 0 10px rgba(0,0,0,0.05); 
}

#fixed-stave {
    width: 150px; 
    height: 180px;
    flex-shrink: 0; 
    position: relative;
    z-index: 10; 
    background-color: var(--surface); 
    box-shadow: 2px 0 5px rgba(0,0,0,0.1); 
}

#notation {
    margin-left: -5px; 
    width: calc(760px - 150px + 5px); 
    height: 180px;
    position: relative;
}

.wrong-flash {
    /* Kept for feedback effect */
}

.stats {
    display: flex;
    justify-content: center;
    gap: 20px;
    font-size: 0.9rem;
    margin-top: 15px;
    font-weight: 500;
}
</style>
</head>

<body class="">

<div class="container" id="card">
<h1>MelodyFlow Practice</h1>

<div id="scale-controls-container">
    </div>

<div class="toggles">
    <label class="toggle">Bass Clef <input type="checkbox" id="clefToggle"></label>
    <label class="toggle">Chord Mode <input type="checkbox" id="chordToggle"></label>
    <label class="toggle">Rhythm Mode <input type="checkbox" id="rhythmToggle"></label>
    <label class="toggle">Dark Mode <input type="checkbox" id="darkModeToggle"></label>
    <button onclick="exportStats()">Export Stats ðŸ“Š</button>
</div>

<div id="notation-window">
    <div id="fixed-stave"></div>
    <div id="notation"></div>
</div>

<div class="stats">
    <div>Accuracy: <span id="accuracy">100%</span></div>
    <div>Streak: <span id="streak">0</span></div>
    <div>Best: <span id="best">0</span></div>
</div>
</div>

<script>
const VF = Vex.Flow;
const NOTES_VISIBLE = 8;
const NOTE_WIDTH = 100;
const FIXED_STAVE_WIDTH = 150;
const ANIMATION_DURATION = 300; // ms (0.3s)
const START_MIDI_NOTE = 60; // Middle C (C4)

let currentScaleName = 'C Major';
let clef = 'treble';
let chordMode = false;
let rhythmMode = false;
let currentKey = 'C';

let sequence = [];
let total = 0, correct = 0;
let streak = 0, best = 0;

// MIDI Note Name Mapping (0-11)
const MIDI_TO_NOTE = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

// VexFlow Key Signatures for common keys
const KEY_SIGNATURES = {
    // Majors
    'C': 'C', 'G': 'G', 'D': 'D', 'A': 'A', 'E': 'E', 'B': 'B', 'F#': 'F#',
    'F': 'F', 'Bb': 'Bb', 'Eb': 'Eb', 'Ab': 'Ab', 'Db': 'Db', 'Gb': 'Gb',
    // Minors (use relative major's signature)
    'Am': 'C', 'Em': 'G', 'Bm': 'D', 'F#m': 'A', 'C#m': 'E', 'G#m': 'B', 'D#m': 'F#',
    'Dm': 'F', 'Gm': 'Bb', 'Cm': 'Eb', 'Fm': 'Ab', 'Bbm': 'Db', 'Ebm': 'Gb'
};

/**
 * Generates VexFlow note strings (e.g., ['c/4', 'd/4', ...]) from a list of MIDI intervals.
 * This is crucial for fixing the "no notes showing" bug by ensuring valid strings.
 * @param {number} rootMidi - The MIDI number of the root note (e.g., 60 for C4).
 * @param {number[]} intervals - List of semitones from the root.
 * @returns {string[]} VexFlow note strings.
 */
function generateVexNotes(rootMidi, intervals) {
    // Only use a subset of the scale notes to keep them in a comfortable singing/sight-reading range (C4 to C5)
    const minMidi = 60; // C4
    const maxMidi = 72; // C5

    let notes = intervals.map(interval => {
        const midi = rootMidi + interval;
        
        // This loop keeps the note within the C4-C5 range by shifting octaves
        let shiftedMidi = midi;
        while (shiftedMidi < minMidi) shiftedMidi += 12;
        while (shiftedMidi > maxMidi) shiftedMidi -= 12;

        const noteIndex = shiftedMidi % 12;
        const octave = Math.floor(shiftedMidi / 12) - 1;
        
        let note = MIDI_TO_NOTE[noteIndex].toLowerCase();
        
        // VexFlow often prefers flats in flat keys (F, Bb, Eb, etc.).
        // Convert sharps to flats for keys with flats to match expected VexFlow notation.
        // This is a common solution for VexFlow input.
        const enharmonicMap = {
            'd#': 'eb', 'g#': 'ab', 'c#': 'db', 'f#': 'gb', 'a#': 'bb'
        };
        const keyName = KEY_SIGNATURES[currentKey] || currentKey;
        if (keyName.includes('b') && enharmonicMap[note]) {
             note = enharmonicMap[note];
        }

        return `${note}/${octave}`;
    });
    
    // Filter to unique notes (e.g., C Major scale only has 8 unique notes)
    return [...new Set(notes)].filter(n => n.length > 2);
}

// Full Major and Minor Scale Data (Root note MIDI number and Intervals)
const ALL_SCALES = {
    'Major Scales': {
        // Intervals: [0, 2, 4, 5, 7, 9, 11, 12] (W W H W W W H)
        'C Major':    { root: 60, key: 'C',   intervals: [0, 2, 4, 5, 7, 9, 11] }, // Root C4 (60)
        'C# Major':   { root: 61, key: 'C#',  intervals: [0, 2, 4, 5, 7, 9, 11] }, // Root C#4 (61)
        'Db Major':   { root: 61, key: 'Db',  intervals: [0, 2, 4, 5, 7, 9, 11] }, // Root Db4 (61)
        'D Major':    { root: 62, key: 'D',   intervals: [0, 2, 4, 5, 7, 9, 11] }, // Root D4 (62)
        'Eb Major':   { root: 63, key: 'Eb',  intervals: [0, 2, 4, 5, 7, 9, 11] }, // Root Eb4 (63)
        'E Major':    { root: 64, key: 'E',   intervals: [0, 2, 4, 5, 7, 9, 11] }, // Root E4 (64)
        'F Major':    { root: 65, key: 'F',   intervals: [0, 2, 4, 5, 7, 9, 11] }, // Root F4 (65)
        'F# Major':   { root: 66, key: 'F#',  intervals: [0, 2, 4, 5, 7, 9, 11] }, // Root F#4 (66)
        'Gb Major':   { root: 66, key: 'Gb',  intervals: [0, 2, 4, 5, 7, 9, 11] }, // Root Gb4 (66)
        'G Major':    { root: 67, key: 'G',   intervals: [0, 2, 4, 5, 7, 9, 11] }, // Root G4 (67)
        'Ab Major':   { root: 68, key: 'Ab',  intervals: [0, 2, 4, 5, 7, 9, 11] }, // Root Ab4 (68)
        'A Major':    { root: 69, key: 'A',   intervals: [0, 2, 4, 5, 7, 9, 11] }, // Root A4 (69)
        'Bb Major':   { root: 70, key: 'Bb',  intervals: [0, 2, 4, 5, 7, 9, 11] }, // Root Bb4 (70)
        'B Major':    { root: 71, key: 'B',   intervals: [0, 2, 4, 5, 7, 9, 11] }, // Root B4 (71)
    },
    'Natural Minor Scales': {
        // Intervals: [0, 2, 3, 5, 7, 8, 10, 12] (W H W W H W W)
        'C Minor':    { root: 60, key: 'Cm',  intervals: [0, 2, 3, 5, 7, 8, 10] }, 
        'C# Minor':   { root: 61, key: 'C#m', intervals: [0, 2, 3, 5, 7, 8, 10] }, 
        'D Minor':    { root: 62, key: 'Dm',  intervals: [0, 2, 3, 5, 7, 8, 10] }, 
        'Eb Minor':   { root: 63, key: 'Ebm', intervals: [0, 2, 3, 5, 7, 8, 10] }, 
        'E Minor':    { root: 64, key: 'Em',  intervals: [0, 2, 3, 5, 7, 8, 10] }, 
        'F Minor':    { root: 65, key: 'Fm',  intervals: [0, 2, 3, 5, 7, 8, 10] }, 
        'F# Minor':   { root: 66, key: 'F#m', intervals: [0, 2, 3, 5, 7, 8, 10] }, 
        'G Minor':    { root: 67, key: 'Gm',  intervals: [0, 2, 3, 5, 7, 8, 10] }, 
        'G# Minor':   { root: 68, key: 'G#m', intervals: [0, 2, 3, 5, 7, 8, 10] }, 
        'A Minor':    { root: 69, key: 'Am',  intervals: [0, 2, 3, 5, 7, 8, 10] }, 
        'Bb Minor':   { root: 70, key: 'Bbm', intervals: [0, 2, 3, 5, 7, 8, 10] }, 
        'B Minor':    { root: 71, key: 'Bm',  intervals: [0, 2, 3, 5, 7, 8, 10] }
    }
};


// Helper function to get the full scale data and generate the note pool
function getScaleData(scaleName) {
    for (const category in ALL_SCALES) {
        const scale = ALL_SCALES[category][scaleName];
        if (scale) {
            currentKey = scale.key; // Set current key signature before generating notes
            scale.notes = generateVexNotes(scale.root, scale.intervals);
            return scale;
        }
    }
    // Default fallback
    currentKey = ALL_SCALES['Major Scales']['C Major'].key;
    const defaultScale = ALL_SCALES['Major Scales']['C Major'];
    defaultScale.notes = generateVexNotes(defaultScale.root, defaultScale.intervals);
    return defaultScale; 
}

function randomNote() {
    const scale = getScaleData(currentScaleName);
    const pool = scale.notes;
    // Notes are already generated in a safe C4-C5 range by generateVexNotes
    return pool[Math.floor(Math.random() * pool.length)];
}

function generateItem() {
    return chordMode ? [randomNote(), randomNote()] : [randomNote()];
}

function start() {
    // Force set currentKey based on selected scale before generating sequence
    const scale = getScaleData(currentScaleName);
    currentKey = KEY_SIGNATURES[scale.key] || scale.key;

    sequence = [];
    for (let i = 0; i < NOTES_VISIBLE; i++) sequence.push(generateItem());
    
    drawFixedStave();
    drawNotes();
}

// --- VexFlow Drawing Functions ---

/**
 * Draws the Clef, Key, and Time Signature once in the fixed area.
 */
function drawFixedStave() {
    const el = document.getElementById('fixed-stave');
    el.innerHTML = '';
    
    const r = new VF.Renderer(el, VF.Renderer.Backends.SVG);
    r.resize(FIXED_STAVE_WIDTH, 180);
    const ctx = r.getContext();

    // Ensure VexFlow honors the dynamic theme color
    const color = getComputedStyle(document.body).getPropertyValue('--on-surface').trim();
    ctx.setFillStyle(color);
    ctx.setStrokeStyle(color);

    const stave = new VF.Stave(0, 40, FIXED_STAVE_WIDTH);
    // Use the VexFlow mapped key signature
    stave.addClef(clef)
          .addTimeSignature("4/4")
          .addKeySignature(KEY_SIGNATURES[currentKey] || currentKey); 
    stave.setContext(ctx).draw();
}

/**
 * Draws only the notes on the scrolling area.
 */
function drawNotes() {
    const el = document.getElementById('notation');
    
    el.innerHTML = '';
    el.style.transform = 'translateX(0)'; 
    el.style.transition = 'none';

    const width = NOTES_VISIBLE * NOTE_WIDTH + 50; 
    
    const r = new VF.Renderer(el, VF.Renderer.Backends.SVG);
    r.resize(width, 180);
    const ctx = r.getContext();

    // Ensure VexFlow honors the dynamic theme color
    const color = getComputedStyle(document.body).getPropertyValue('--on-surface').trim();
    ctx.setFillStyle(color);
    ctx.setStrokeStyle(color);

    // Staff line slightly overlaps fixed staff for continuity
    const stave = new VF.Stave(-5, 40, width + 5); 
    stave.setContext(ctx).draw();
    
    const durationType = rhythmMode ? '8' : 'q';
    
    const notes = sequence.map((keys, i) => {
        const n = new VF.StaveNote({
            keys,
            duration: durationType, 
            clef
        });
        // Add a KeySig to each note to ensure VexFlow correctly renders accidentals
        // This is crucial for notes that fall outside the key signature (e.g., F# in C Major)
        new VF.KeySig(KEY_SIGNATURES[currentKey] || currentKey).attach(n);
        
        n.setAttribute('data-i', i);
        return n;
    });

    const voice = new VF.Voice({ 
        num_beats: NOTES_VISIBLE * (rhythmMode ? 0.5 : 1), 
        beat_value: 4 
    });
    
    voice.addTickables(notes);
    new VF.Formatter().joinVoices([voice]).format([voice], width);
    voice.draw(ctx, stave);

    highlight();
}


function highlight() {
    // Note: VexFlow notes are colored via inline styles, we need to apply theme var() here
    document.querySelectorAll('#notation .vf-notehead path').forEach(p => p.style.fill = 'var(--default-note)');
    
    const targetNoteElement = document.querySelector('#notation [data-i="0"]');
    if (!targetNoteElement) return;
    
    targetNoteElement.querySelectorAll('.vf-notehead path').forEach(p => p.style.fill = 'var(--target-note)');
}

function correctNote() {
    const el = document.getElementById('notation');
    el.style.transition = `transform ${ANIMATION_DURATION}ms ease-out`;
    el.style.transform = `translateX(-${NOTE_WIDTH}px)`;

    setTimeout(() => {
        sequence.shift();
        sequence.push(generateItem());
        
        correct++; streak++; best = Math.max(best, streak);
        updateStats();
        
        drawNotes(); 
    }, ANIMATION_DURATION); 
}

function wrongNote() {
    const windowEl = document.getElementById('notation-window');
    windowEl.classList.add('wrong-flash');
    streak = 0;
    setTimeout(() => windowEl.classList.remove('wrong-flash'), 300); 
}

function updateStats() {
    total++;
    document.getElementById('accuracy').innerText =
        (total === 0 ? 100 : Math.round((correct / total) * 100)) + '%';
    document.getElementById('streak').innerText = streak;
    document.getElementById('best').innerText = best;
}

function midiToVex(m) {
    const noteIndex = m % 12;
    const octave = Math.floor(m / 12) - 1;
    let note = MIDI_TO_NOTE[noteIndex].toLowerCase();
    
    // Apply common enharmonic mapping to match VexFlow's rendering, especially for flat keys
    const enharmonicMap = {
        'd#': 'eb', 'g#': 'ab', 'c#': 'db', 'f#': 'gb', 'a#': 'bb'
    };
    const keyName = KEY_SIGNATURES[currentKey] || currentKey;
    if (keyName.includes('b') && enharmonicMap[note]) {
         note = enharmonicMap[note];
    }

    return `${note}/${octave}`;
}

const pressedKeys = new Set(); 

navigator.requestMIDIAccess().then(m => {
    for (let input of m.inputs.values()) {
        input.onmidimessage = e => {
            const status = e.data[0];
            const midiNote = e.data[1];
            const velocity = e.data[2];
            const playedVex = midiToVex(midiNote);

            if (status === 144 && velocity > 0) { // Note On
                pressedKeys.add(playedVex);
                
                if (chordMode) {
                    const targetChord = sequence[0];
                    const allMatch = targetChord.every(note => pressedKeys.has(note)) && (targetChord.length === pressedKeys.size);

                    if (allMatch) {
                        correctNote();
                        pressedKeys.clear(); 
                    } else if (!targetChord.includes(playedVex)) {
                        wrongNote();
                        updateStats(); 
                    }
                } else {
                    total++; 
                    if (sequence[0].includes(playedVex)) {
                        correctNote();
                    } else {
                        wrongNote();
                    }
                    updateStats();
                }
            } else if (status === 128 || (status === 144 && velocity === 0)) { // Note Off
                pressedKeys.delete(playedVex);
            }
        };
    }
});

// --- UI Control Functions ---

function generateScaleControls() {
    const container = document.getElementById('scale-controls-container');
    let html = '';
    let isFirstButton = true;

    for (const category in ALL_SCALES) {
        html += `<div class="scale-category"><h3>${category}</h3><div class="controls">`;
        
        for (const scaleName in ALL_SCALES[category]) {
            // Set the first scale button to active by default
            const isActive = isFirstButton ? 'active' : '';
            
            html += `<button class="${isActive}" onclick="setScale('${scaleName}', event)">${scaleName}</button>`;
            
            if (isFirstButton) {
                currentScaleName = scaleName;
                isFirstButton = false;
            }
        }
        
        html += `</div></div>`;
    }
    
    container.innerHTML = html;
}


function setScale(s, event) {
    currentScaleName = s;
    
    // Deactivate all buttons across all groups
    document.querySelectorAll('#scale-controls-container button').forEach(b => b.classList.remove('active'));
    
    // Activate the clicked button
    if(event && event.target) {
        event.target.classList.add('active');
    }
    
    // Reset stats/streak when changing scales
    total = 0; correct = 0; streak = 0; best = 0;
    updateStats();
    start();
}

document.getElementById('clefToggle').onchange = e => {
    clef = e.target.checked ? 'bass' : 'treble';
    start(); 
};
document.getElementById('chordToggle').onchange = e => {
    chordMode = e.target.checked;
    start();
};
document.getElementById('rhythmToggle').onchange = e => {
    rhythmMode = e.target.checked;
    start();
};

document.getElementById('darkModeToggle').onchange = e => {
    document.body.classList.toggle('dark-mode', e.target.checked);
    // Redraw staves to update VexFlow colors (staff lines and notes)
    start(); 
};

function exportStats() {
    const stats = {
        scale: currentScaleName,
        clef: clef,
        chordMode: chordMode,
        rhythmMode: rhythmMode,
        totalAttempts: total,
        totalCorrect: correct,
        accuracy: (total === 0 ? 100 : Math.round((correct / total) * 100)) + '%',
        currentStreak: streak,
        bestStreak: best,
        exportTime: new Date().toISOString()
    };

    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(stats, null, 2));
    const downloadAnchorNode = document.createElement('a');
    downloadAnchorNode.setAttribute("href", dataStr);
    downloadAnchorNode.setAttribute("download", "MelodyFlow_Stats.json");
    document.body.appendChild(downloadAnchorNode);
    downloadAnchorNode.click();
    downloadAnchorNode.remove();
}

// --- Initialization ---
generateScaleControls();
start();
</script>

</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MelodyFlow v5.3 - Seamless Stave</title>

<script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.2/build/cjs/vexflow.js"></script>

<style>
:root {
    --primary: #6750A4;
    --surface: #F7F2FA;
    --background: #FEF7FF;
    --outline: #79747E;
    --target-note: #00A96B;
    --default-note: #6750A4;
    --wrong-flash: #F2B8B5;
}

body {
    font-family: 'Segoe UI', Roboto, sans-serif;
    background: var(--background);
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
}

.container {
    background: var(--surface);
    padding: 32px;
    border-radius: 28px;
    width: 95%;
    max-width: 960px;
    text-align: center;
    box-shadow: 0 10px 30px rgba(0,0,0,.15);
}

h1 { color: var(--primary); margin-bottom: 10px; }

.controls, .toggles, .scale-selector {
    display: flex;
    justify-content: center;
    gap: 10px;
    flex-wrap: wrap;
    margin-bottom: 12px;
}

.scale-selector {
    margin-top: 8px;
}

button {
    border: 1px solid var(--outline);
    background: transparent;
    padding: 8px 18px;
    border-radius: 18px;
    cursor: pointer;
}

button.active {
    background: var(--primary);
    color: white;
}

select {
    border: 1px solid var(--outline);
    background: transparent;
    padding: 8px 18px;
    border-radius: 18px;
    cursor: pointer;
    font-family: inherit;
    font-size: 0.95rem;
    color: var(--primary);
    min-width: 150px;
}

.toggle {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 0.85rem;
}

.toggle input {
    appearance: none;
    width: 34px;
    height: 18px;
    background: #bbb;
    border-radius: 9px;
    position: relative;
}

.toggle input:checked { background: var(--primary); }

.toggle input::after {
    content: '';
    width: 14px;
    height: 14px;
    background: white;
    border-radius: 50%;
    position: absolute;
    top: 2px;
    left: 2px;
    transition: transform .2s;
}

.toggle input:checked::after {
    transform: translateX(16px);
}

#notation-window {
    width: 760px;
    height: 180px;
    margin: 20px auto;
    overflow: hidden;
    border-radius: 16px;
    border: 2px solid var(--primary);
    position: relative;
    display: flex;
}

#fixed-stave {
    width: 150px; 
    height: 180px;
    flex-shrink: 0; 
    position: relative;
    z-index: 10; 
    background-color: var(--surface); 
}

#notation {
    margin-left: -5px; 
    width: calc(760px - 150px + 5px);
    height: 180px;
    position: relative;
}

.wrong-flash {
    animation: shake .3s;
    background-color: var(--wrong-flash); 
    border-color: #E35050 !important;
}

@keyframes shake {
    0% { transform: translateX(0); }
    25% { transform: translateX(-2px); }
    50% { transform: translateX(2px); }
    75% { transform: translateX(-2px); }
    100% { transform: translateX(0); }
}

.stats {
    display: flex;
    justify-content: center;
    gap: 20px;
    font-size: 0.85rem;
    margin-top: 15px;
}
</style>
</head>

<body>

<div class="container" id="card">
<h1>MelodyFlow</h1>

<div class="controls">
    <button id="btn-beginner" class="active" onclick="setDifficulty('Beginner', event)">Beginner</button>
    <button id="btn-intermediate" onclick="setDifficulty('Intermediate', event)">Intermediate</button>
    <button id="btn-advanced" onclick="setDifficulty('Advanced', event)">Advanced</button>
</div>

<div class="scale-selector">
    <select id="scaleSelect" onchange="changeScale()">
        <option value="random">ðŸŽ² Random Key</option>
        <optgroup label="Major Scales (Circle of 5ths)">
            <option value="C">C Major</option>
            <option value="G">G Major</option>
            <option value="D">D Major</option>
            <option value="A">A Major</option>
            <option value="E">E Major</option>
            <option value="B">B Major</option>
            <option value="F#">Fâ™¯ Major</option>
            <option value="C#">Câ™¯ Major</option>
        </optgroup>
        <optgroup label="Relative Minor Scales">
            <option value="Am">A Minor (C Major)</option>
            <option value="Em">E Minor (G Major)</option>
            <option value="Bm">B Minor (D Major)</option>
            <option value="F#m">Fâ™¯ Minor (A Major)</option>
            <option value="C#m">Câ™¯ Minor (E Major)</option>
            <option value="G#m">Gâ™¯ Minor (B Major)</option>
            <option value="D#m">Dâ™¯ Minor (Fâ™¯ Major)</option>
            <option value="A#m">Aâ™¯ Minor (Câ™¯ Major)</option>
        </optgroup>
    </select>
</div>

<div class="toggles">
    <label class="toggle">Bass Clef <input type="checkbox" id="clefToggle"></label>
    <label class="toggle">Chord Mode <input type="checkbox" id="chordToggle"></label>
    <label class="toggle">Rhythm Mode <input type="checkbox" id="rhythmToggle"></label>
    <button onclick="exportStats()">Export Stats ðŸ“Š</button>
</div>

<div id="notation-window">
    <div id="fixed-stave"></div>
    <div id="notation"></div>
</div>

<div class="stats">
    <div>Accuracy: <span id="accuracy">100%</span></div>
    <div>Streak: <span id="streak">0</span></div>
    <div>Best: <span id="best">0</span></div>
</div>
</div>

<script>
const VF = Vex.Flow;
const NOTES_VISIBLE = 8;
const NOTE_WIDTH = 100;
const FIXED_STAVE_WIDTH = 150;
const ANIMATION_DURATION = 300;

let difficulty = 'Beginner';
let clef = 'treble';
let chordMode = false;
let rhythmMode = false;
let currentKey = 'C';
let scaleMode = 'random'; // 'random' or 'fixed'

let sequence = [];
let total = 0, correct = 0;
let streak = 0, best = 0;

const ranges = {
    Beginner: {
        keys: ['C'],
        notes: ['c/4','d/4','e/4','f/4','g/4']
    },
    Intermediate: {
        keys: ['G', 'F', 'D'],
        notes: ['a/3','b/3','c/4','d/4','e/4','f/4','g/4','a/4','b/4','c/5']
    },
    Advanced: {
        keys: ['A', 'E', 'Eb', 'B'],
        notes: ['f/3','g/3','a/3','b/3','c/4','d/4','e/4','f/4','g/4','a/4','b/4','c/5','d/5']
    }
};

// Scale definitions for note generation
const scaleDefinitions = {
    // Major scales with their relative minors
    'C': { type: 'major', notes: ['c/4','d/4','e/4','f/4','g/4','a/4','b/4'] },
    'G': { type: 'major', notes: ['g/4','a/4','b/4','c/5','d/5','e/5','f#/5'] },
    'D': { type: 'major', notes: ['d/4','e/4','f#/4','g/4','a/4','b/4','c#/5'] },
    'A': { type: 'major', notes: ['a/3','b/3','c#/4','d/4','e/4','f#/4','g#/4'] },
    'E': { type: 'major', notes: ['e/4','f#/4','g#/4','a/4','b/4','c#/5','d#/5'] },
    'B': { type: 'major', notes: ['b/3','c#/4','d#/4','e/4','f#/4','g#/4','a#/4'] },
    'F#': { type: 'major', notes: ['f#/3','g#/3','a#/3','b/3','c#/4','d#/4','f/4'] },
    'C#': { type: 'major', notes: ['c#/4','d#/4','f/4','f#/4','g#/4','a#/4','c/5'] },
    
    // Relative minor scales
    'Am': { type: 'minor', notes: ['a/3','b/3','c/4','d/4','e/4','f/4','g/4'] },
    'Em': { type: 'minor', notes: ['e/3','f#/3','g/3','a/3','b/3','c/4','d/4'] },
    'Bm': { type: 'minor', notes: ['b/3','c#/4','d/4','e/4','f#/4','g/4','a/4'] },
    'F#m': { type: 'minor', notes: ['f#/3','g#/3','a/3','b/3','c#/4','d/4','e/4'] },
    'C#m': { type: 'minor', notes: ['c#/4','d#/4','e/4','f#/4','g#/4','a/4','b/4'] },
    'G#m': { type: 'minor', notes: ['g#/3','a#/3','b/3','c#/4','d#/4','e/4','f#/4'] },
    'D#m': { type: 'minor', notes: ['d#/4','f/4','f#/4','g#/4','a#/4','b/4','c#/5'] },
    'A#m': { type: 'minor', notes: ['a#/3','c/4','c#/4','d#/4','f/4','f#/4','g#/4'] }
};

function getNotesForCurrentScale() {
    const scaleSelect = document.getElementById('scaleSelect');
    const selectedScale = scaleSelect.value;
    
    if (selectedScale === 'random') {
        scaleMode = 'random';
        return ranges[difficulty].notes;
    } else {
        scaleMode = 'fixed';
        const scaleNotes = scaleDefinitions[selectedScale];
        
        // Filter notes to match current clef range
        if (clef === 'treble') {
            return scaleNotes.notes.filter(note => {
                const octave = parseInt(note.split('/')[1]);
                return octave >= 3 && octave <= 5;
            });
        } else {
            // Bass clef - lower octaves
            return scaleNotes.notes.filter(note => {
                const octave = parseInt(note.split('/')[1]);
                return octave >= 1 && octave <= 3;
            });
        }
    }
}

function randomNote() {
    const pool = getNotesForCurrentScale();
    if (pool.length === 0) {
        // Fallback to default if no notes in range
        return ranges[difficulty].notes[0];
    }
    return pool[Math.floor(Math.random() * pool.length)];
}

function generateItem() {
    return chordMode ? [randomNote(), randomNote()] : [randomNote()];
}

function start() {
    sequence = [];
    for (let i = 0; i < NOTES_VISIBLE; i++) sequence.push(generateItem());
    
    if (scaleMode === 'random') {
        const keys = ranges[difficulty].keys;
        currentKey = keys[Math.floor(Math.random() * keys.length)];
    } else {
        const selectedScale = document.getElementById('scaleSelect').value;
        // Extract major key from scale name (remove 'm' for minor)
        currentKey = selectedScale.endsWith('m') ? selectedScale.slice(0, -1) : selectedScale;
    }
    
    drawFixedStave();
    drawNotes();
}

function drawFixedStave() {
    const el = document.getElementById('fixed-stave');
    el.innerHTML = '';
    
    const r = new VF.Renderer(el, VF.Renderer.Backends.SVG);
    r.resize(FIXED_STAVE_WIDTH, 180);
    const ctx = r.getContext();

    const stave = new VF.Stave(0, 40, FIXED_STAVE_WIDTH);
    stave.addClef(clef)
          .addTimeSignature("4/4")
          .addKeySignature(currentKey); 
    stave.setContext(ctx).draw();
}

function drawNotes() {
    const el = document.getElementById('notation');
    
    el.innerHTML = '';
    el.style.transform = 'translateX(0)';
    el.style.transition = 'none';

    const noteAreaWidth = 760 - FIXED_STAVE_WIDTH;
    const width = NOTES_VISIBLE * NOTE_WIDTH + 50;
    
    const r = new VF.Renderer(el, VF.Renderer.Backends.SVG);
    r.resize(width, 180);
    const ctx = r.getContext();

    const stave = new VF.Stave(-5, 40, width + 5);
    stave.setContext(ctx).draw();
    
    const durationType = rhythmMode ? '8' : 'q';
    
    const notes = sequence.map((keys, i) => {
        const n = new VF.StaveNote({
            keys,
            duration: durationType, 
            clef
        });
        n.setAttribute('data-i', i);
        return n;
    });

    const voice = new VF.Voice({ 
        num_beats: NOTES_VISIBLE * (rhythmMode ? 0.5 : 1), 
        beat_value: 4 
    });
    
    voice.addTickables(notes);
    new VF.Formatter().joinVoices([voice]).format([voice], width);
    voice.draw(ctx, stave);

    highlight();
}

function highlight() {
    document.querySelectorAll('#notation .vf-notehead path').forEach(p => p.style.fill = 'var(--default-note)');
    
    const targetNoteElement = document.querySelector('#notation [data-i="0"]');
    if (!targetNoteElement) return;
    
    targetNoteElement.querySelectorAll('.vf-notehead path').forEach(p => p.style.fill = 'var(--target-note)');
}

function correctNote() {
    const el = document.getElementById('notation');
    
    el.style.transition = `transform ${ANIMATION_DURATION}ms ease-out`;
    el.style.transform = `translateX(-${NOTE_WIDTH}px)`;

    setTimeout(() => {
        sequence.shift();
        sequence.push(generateItem());
        
        correct++; streak++; best = Math.max(best, streak);
        updateStats();
        
        drawNotes();
        
    }, ANIMATION_DURATION);
}

function wrongNote() {
    const windowEl = document.getElementById('notation-window');
    windowEl.classList.add('wrong-flash');
    streak = 0;
    setTimeout(() => windowEl.classList.remove('wrong-flash'), 300);
}

function updateStats() {
    total++;
    document.getElementById('accuracy').innerText =
        (total === 0 ? 100 : Math.round((correct / total) * 100)) + '%';
    document.getElementById('streak').innerText = streak;
    document.getElementById('best').innerText = best;
}

function midiToVex(m) {
    const n = ['c','c#','d','d#','e','f','f#','g','g#','a','a#','b'];
    return `${n[m%12]}${m%12 === 1 || m%12 === 3 || m%12 === 6 || m%12 === 8 || m%12 === 10 ? '#' : ''}/${Math.floor(m/12)-1}`;
}

const pressedKeys = new Set();

navigator.requestMIDIAccess().then(m => {
    for (let input of m.inputs.values()) {
        input.onmidimessage = e => {
            const status = e.data[0];
            const midiNote = e.data[1];
            const velocity = e.data[2];
            const playedVex = midiToVex(midiNote);

            if (status === 144 && velocity > 0) {
                pressedKeys.add(playedVex);
                
                if (chordMode) {
                    const targetChord = sequence[0];
                    const allMatch = targetChord.every(note => pressedKeys.has(note)) && (targetChord.length === pressedKeys.size);

                    if (allMatch) {
                        correctNote();
                        pressedKeys.clear();
                    } else if (!targetChord.includes(playedVex)) {
                        wrongNote();
                        updateStats();
                    }
                } else {
                    total++;
                    if (sequence[0].includes(playedVex)) {
                        correctNote();
                    } else {
                        wrongNote();
                    }
                    updateStats();
                }
            } else if (status === 128 || (status === 144 && velocity === 0)) {
                pressedKeys.delete(playedVex);
            }
        };
    }
});

document.getElementById('clefToggle').onchange = e => {
    clef = e.target.checked ? 'bass' : 'treble';
    start();
};
document.getElementById('chordToggle').onchange = e => {
    chordMode = e.target.checked;
    start();
};
document.getElementById('rhythmToggle').onchange = e => {
    rhythmMode = e.target.checked;
    start();
};

function changeScale() {
    start();
}

function setDifficulty(d, event) {
    difficulty = d;
    document.querySelectorAll('.controls button').forEach(b => b.classList.remove('active'));
    if(event && event.target) {
        event.target.classList.add('active');
    }
    start();
}

function exportStats() {
    const stats = {
        difficulty: difficulty,
        clef: clef,
        chordMode: chordMode,
        rhythmMode: rhythmMode,
        scale: document.getElementById('scaleSelect').value,
        totalAttempts: total,
        totalCorrect: correct,
        accuracy: (total === 0 ? 100 : Math.round((correct / total) * 100)) + '%',
        currentStreak: streak,
        bestStreak: best,
        exportTime: new Date().toISOString()
    };

    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(stats, null, 2));
    const downloadAnchorNode = document.createElement('a');
    downloadAnchorNode.setAttribute("href", dataStr);
    downloadAnchorNode.setAttribute("download", "MelodyFlow_Stats.json");
    document.body.appendChild(downloadAnchorNode);
    downloadAnchorNode.click();
    downloadAnchorNode.remove();
}

start();
</script>

</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MelodyFlow v5.4 - Scale Constraint</title>

<script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.2/build/cjs/vexflow.js"></script>

<style>
:root {
Â  Â  --primary: #6750A4;
Â  Â  --surface: #F7F2FA;
Â  Â  --background: #FEF7FF;
Â  Â  --outline: #79747E;
Â  Â  --target-note: #00A96B;
Â  Â  --default-note: #6750A4;
Â  Â  --wrong-flash: #F2B8B5;
}

body {
Â  Â  font-family: 'Segoe UI', Roboto, sans-serif;
Â  Â  background: var(--background);
Â  Â  display: flex;
Â  Â  justify-content: center;
Â  Â  align-items: center;
Â  Â  height: 100vh;
Â  Â  margin: 0;
}

.container {
Â  Â  background: var(--surface);
Â  Â  padding: 32px;
Â  Â  border-radius: 28px;
Â  Â  width: 95%;
Â  Â  max-width: 960px;
Â  Â  text-align: center;
Â  Â  box-shadow: 0 10px 30px rgba(0,0,0,.15);
}

h1 { color: var(--primary); margin-bottom: 10px; }

.controls, .toggles {
Â  Â  display: flex;
Â  Â  justify-content: center;
Â  Â  gap: 10px;
Â  Â  flex-wrap: wrap;
Â  Â  margin-bottom: 12px;
}

button {
Â  Â  border: 1px solid var(--outline);
Â  Â  background: transparent;
Â  Â  padding: 8px 18px;
Â  Â  border-radius: 18px;
Â  Â  cursor: pointer;
}

button.active {
Â  Â  background: var(--primary);
Â  Â  color: white;
}

.toggle {
Â  Â  display: flex;
Â  Â  align-items: center;
Â  Â  gap: 6px;
Â  Â  font-size: 0.85rem;
}

.toggle input {
Â  Â  appearance: none;
Â  Â  width: 34px;
Â  Â  height: 18px;
Â  Â  background: #bbb;
Â  Â  border-radius: 9px;
Â  Â  position: relative;
}

.toggle input:checked { background: var(--primary); }

.toggle input::after {
Â  Â  content: '';
Â  Â  width: 14px;
Â  Â  height: 14px;
Â  Â  background: white;
Â  Â  border-radius: 50%;
Â  Â  position: absolute;
Â  Â  top: 2px;
Â  Â  left: 2px;
Â  Â  transition: transform .2s;
}

.toggle input:checked::after {
Â  Â  transform: translateX(16px);
}

#notation-window {
Â  Â  width: 760px;
Â  Â  height: 180px;
Â  Â  margin: 20px auto;
Â  Â  overflow: hidden;
Â  Â  border-radius: 16px;
Â  Â  border: 2px solid var(--primary);
Â  Â  position: relative;
Â  Â  display: flex;
}

/* New element for the non-moving part */
#fixed-stave {
Â  Â  width: 150px;Â 
Â  Â  height: 180px;
Â  Â  flex-shrink: 0;Â 
Â  Â  position: relative;
Â  Â  z-index: 10;Â 
Â  Â  background-color: var(--surface);Â 
}

/* The element that holds the scrolling notes */
#notation {
Â  Â  /* Use a negative margin to visually overlap the staves and hide the gap */
Â  Â  margin-left: -5px;Â 
Â  Â  width: calc(760px - 150px + 5px); /* Adjusted width to compensate for negative margin */
Â  Â  height: 180px;
Â  Â  position: relative;
Â  Â  /* FIX: The transition will be applied and removed dynamically in JS to prevent "bounce" */
Â  Â  /* Remove the static transition line here */
}


/* Reduced shake animation and targeted to notation area */
.wrong-flash {
Â  Â  animation: shake .3s;
Â  Â  background-color: var(--wrong-flash);Â 
Â  Â  border-color: #E35050 !important;
}

@keyframes shake {
Â  Â  0% { transform: translateX(0); }
Â  Â  25% { transform: translateX(-2px); }
Â  Â  50% { transform: translateX(2px); }
Â  Â  75% { transform: translateX(-2px); }
Â  Â  100% { transform: translateX(0); }
}

.stats {
Â  Â  display: flex;
Â  Â  justify-content: center;
Â  Â  gap: 20px;
Â  Â  font-size: 0.85rem;
Â  Â  margin-top: 15px;
}
</style>
</head>

<body>

<div class="container" id="card">
<h1>MelodyFlow</h1>

<div class="controls">
Â  Â  <button id="btn-beginner" class="active" onclick="setDifficulty('Beginner', event)">Beginner</button>
Â  Â  <button id="btn-intermediate" onclick="setDifficulty('Intermediate', event)">Intermediate</button>
Â  Â  <button id="btn-advanced" onclick="setDifficulty('Advanced', event)">Advanced</button>
Â  Â  
Â  Â  Â  Â  <select id="scale-select" onchange="setCurrentKey(this.value)">
Â  Â  Â  Â  Â  Â  </select>
</div>

<div class="toggles">
Â  Â  <label class="toggle">Bass Clef <input type="checkbox" id="clefToggle"></label>
Â  Â  <label class="toggle">Chord Mode <input type="checkbox" id="chordToggle"></label>
Â  Â  <label class="toggle">Rhythm Mode <input type="checkbox" id="rhythmToggle"></label>
Â  Â  <button onclick="exportStats()">Export Stats ðŸ“Š</button>
</div>

<div id="notation-window">
Â  Â  <div id="fixed-stave"></div>
Â  Â  <div id="notation"></div>
</div>

<div class="stats">
Â  Â  <div>Accuracy: <span id="accuracy">100%</span></div>
Â  Â  <div>Streak: <span id="streak">0</span></div>
Â  Â  <div>Best: <span id="best">0</span></div>
</div>
</div>

<script>
const VF = Vex.Flow;
const NOTES_VISIBLE = 8;
const NOTE_WIDTH = 100; // Estimated width of a note block for sliding
const FIXED_STAVE_WIDTH = 150; // Must match CSS
const ANIMATION_DURATION = 300; // ms (0.3s)

// --- MUSIC THEORY DATA ---
// Major Key: Relative Minor (In order of Circle of Fifths, sharp keys only)
const SHARP_KEYS = [
Â  Â  { name: 'C Major / A Minor', key: 'C' },
Â  Â  { name: 'G Major / E Minor', key: 'G' },
Â  Â  { name: 'D Major / B Minor', key: 'D' },
Â  Â  { name: 'A Major / F# Minor', key: 'A' },
Â  Â  { name: 'E Major / C# Minor', key: 'E' },
Â  Â  { name: 'B Major / G# Minor', key: 'B' },
Â  Â  { name: 'F# Major / D# Minor', key: 'F#' },
Â  Â  { name: 'C# Major / A# Minor', key: 'C#' },
];

// Chromatic pitches for calculating scale notes
const PITCHES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

let difficulty = 'Beginner';
let clef = 'treble';
let chordMode = false;
let rhythmMode = false;
let currentKey = 'C';
let selectedScaleKey = 'C'; 
let currentNotePool = []; // NEW: Array of notes (e.g., 'c/4', 'g/4') constrained by scale and range

let sequence = [];
let total = 0, correct = 0;
let streak = 0, best = 0;

const ranges = {
Â  Â  Beginner: {
Â  Â  Â  Â  notes: ['c/4','d/4','e/4','f/4','g/4'] // C4 to G4
Â  Â  },
Â  Â  Intermediate: {
Â  Â  Â  Â  notes: ['a/3','b/3','c/4','d/4','e/4','f/4','g/4','a/4','b/4','c/5'] // A3 to C5
Â  Â  },
Â  Â  Advanced: {
Â  Â  Â  Â  notes: ['f/3','g/3','a/3','b/3','c/4','d/4','e/4','f/4','g/4','a/4','b/4','c/5','d/5'] // F3 to D5
Â  Â  }
};

// --- NEW MUSIC THEORY LOGIC ---

/**
 * Calculates the notes of a scale given a key signature,
 * then filters them to fit the current difficulty's octave range.
 * @returns {Array<string>} An array of notes like ['c/4', 'd/4', 'e/4', ...].
 */
function calculateConstrainedNotePool() {
Â  Â  const key = selectedScaleKey;
Â  Â  const scaleIntervals = [0, 2, 4, 5, 7, 9, 11]; // Major scale intervals (semitones)
Â  Â  const keyIndex = PITCHES.indexOf(key.replace('#','')); // Find index of key root (ignoring accidental for lookup)

Â  Â  if (keyIndex === -1) {
Â  Â  Â  Â  console.error("Invalid key:", key);
Â  Â  Â  Â  return [];
Â  Â  }

Â  Â  const notesInScale = new Set();
Â  Â  // VexFlow key signatures handle accidentals, so we just need the letter names
Â  Â  // We will use the pitches array for the note names.
Â  Â  
Â  Â  for (let i = 0; i < scaleIntervals.length; i++) {
Â  Â  Â  Â  const semitones = scaleIntervals[i];
Â  Â  Â  Â  // Calculate the index of the note in the chromatic PITCHES array
Â  Â  Â  Â  const noteIndex = (keyIndex + semitones) % 12;
Â  Â  Â  Â  // Get the basic note name (C, G, D, etc. - includes sharps if VexFlow standard)
Â  Â  Â  Â  const noteName = PITCHES[noteIndex].toLowerCase().replace('b', '#'); // Ensure sharps are used (e.g., F# not Gb)
Â  Â  Â  Â  
Â  Â  Â  Â  // Check if the pitch name is correct for the key (VexFlow handles the rest)
Â  Â  Â  Â  // Since we are only using sharp keys, this is simpler.
Â  Â  Â  Â  notesInScale.add(noteName);
Â  Â  }
Â  Â  
Â  Â  // Filter the difficulty range notes to only include notes from the selected scale
Â  Â  const difficultyRangeNotes = ranges[difficulty].notes;
Â  Â  const constrainedPool = difficultyRangeNotes.filter(vexNote => {
Â  Â  Â  Â  // vexNote is 'c/4', 'd/4', etc.
Â  Â  Â  Â  const notePitch = vexNote.split('/')[0]; // 'c', 'd#', etc.
Â  Â  Â  Â  return notesInScale.has(notePitch.replace('#','')); // Check against the scale degrees
Â  Â  });
Â  Â  
Â  Â  return constrainedPool;
}

// --- CORE FUNCTIONS MODIFIED ---

function randomNote() {
Â  Â  const pool = currentNotePool; // Use the constrained pool
Â  Â  if (pool.length === 0) {
Â  Â  Â  Â  console.warn("Note pool is empty! Check scale and range settings.");
Â  Â  Â  Â  return 'c/4'; // Fallback
Â  Â  }
Â  Â  return pool[Math.floor(Math.random() * pool.length)];
}

function generateItem() {
Â  Â  return chordMode ? [randomNote(), randomNote()] : [randomNote()];
}

function start() {
Â  Â  // 1. Calculate the notes based on scale and difficulty range
Â  Â  currentNotePool = calculateConstrainedNotePool(); 
Â  Â  
Â  Â  // 2. Generate the sequence
Â  Â  sequence = [];
Â  Â  for (let i = 0; i < NOTES_VISIBLE; i++) sequence.push(generateItem());
Â  Â  
Â  Â  // 3. Set the key signature for VexFlow
Â  Â  currentKey = selectedScaleKey; 
Â  Â  
Â  Â  // 4. Draw
Â  Â  drawFixedStave();
Â  Â  drawNotes();
}

/**
 * Populates the scale selection dropdown with the SHARP_KEYS data.
 */
function populateScaleDropdown() {
Â  Â  const select = document.getElementById('scale-select');
Â  Â  select.innerHTML = '';
Â  Â  
Â  Â  SHARP_KEYS.forEach(scale => {
Â  Â  Â  Â  const option = document.createElement('option');
Â  Â  Â  Â  option.value = scale.key;
Â  Â  Â  Â  option.textContent = scale.name;
Â  Â  Â  Â  select.appendChild(option);
Â  Â  });
Â  Â  
Â  Â  // Set the initial selected scale key
Â  Â  selectedScaleKey = SHARP_KEYS[0].key; 
}

/**
 * Updates the current key when the dropdown selection changes.
 * @param {string} key - The new key (e.g., 'G', 'D', 'F#').
 */
function setCurrentKey(key) {
Â  Â  selectedScaleKey = key;
Â  Â  resetStats();
Â  Â  start(); 
}

function setDifficulty(d, event) {
Â  Â  difficulty = d;
Â  Â  document.querySelectorAll('.controls button').forEach(b => b.classList.remove('active'));
Â  Â  if(event && event.target) {
Â  Â  Â  Â  event.target.classList.add('active');
Â  Â  }
Â  Â  resetStats();
Â  Â  start();
}

function resetStats() {
Â  Â  total = 0;
Â  Â  correct = 0;
Â  Â  streak = 0;
Â  Â  document.getElementById('accuracy').innerText = '100%';
Â  Â  document.getElementById('streak').innerText = '0';
}
// --- END CORE FUNCTIONS MODIFIED ---


/**
 * Draws the Clef, Key, and Time Signature once in the fixed area.
 */
function drawFixedStave() {
Â  Â  const el = document.getElementById('fixed-stave');
Â  Â  el.innerHTML = '';
Â  Â  
Â  Â  const r = new VF.Renderer(el, VF.Renderer.Backends.SVG);
Â  Â  r.resize(FIXED_STAVE_WIDTH, 180);
Â  Â  const ctx = r.getContext();

Â  Â  // Create a narrow stave for the fixed elements
Â  Â  const stave = new VF.Stave(0, 40, FIXED_STAVE_WIDTH);
Â  Â  stave.addClef(clef)
Â  Â  Â  Â  Â  .addTimeSignature("4/4")
Â  Â  Â  Â  Â  .addKeySignature(currentKey); 
Â  Â  stave.setContext(ctx).draw();
}

/**
 * Draws only the notes on the scrolling area.
 */
function drawNotes() {
Â  Â  const el = document.getElementById('notation');
Â  Â  
Â  Â  el.innerHTML = '';
Â  Â  el.style.transform = 'translateX(0)'; // Reset transformation to 0
Â  Â  el.style.transition = 'none'; // FIX: Ensure reset is instantaneous (no bounce)

Â  Â  const noteAreaWidth = 760 - FIXED_STAVE_WIDTH;
Â  Â  const width = NOTES_VISIBLE * NOTE_WIDTH + 50; 
Â  Â  
Â  Â  const r = new VF.Renderer(el, VF.Renderer.Backends.SVG);
Â  Â  r.resize(width, 180);
Â  Â  const ctx = r.getContext();

Â  Â  // FIX: Start the staff line slightly to the left (e.g., at X=-5) 
Â  Â  const stave = new VF.Stave(-5, 40, width + 5); 
Â  Â  stave.setContext(ctx).draw();
Â  Â  
Â  Â  const durationType = rhythmMode ? '8' : 'q';
Â  Â  
Â  Â  const notes = sequence.map((keys, i) => {
Â  Â  Â  Â  const n = new VF.StaveNote({
Â  Â  Â  Â  Â  Â  keys,
Â  Â  Â  Â  Â  Â  duration: durationType, 
Â  Â  Â  Â  Â  Â  clef
Â  Â  Â  Â  });
Â  Â  Â  Â  n.setAttribute('data-i', i);
Â  Â  Â  Â  return n;
Â  Â  });

Â  Â  const voice = new VF.Voice({ 
Â  Â  Â  Â  num_beats: NOTES_VISIBLE * (rhythmMode ? 0.5 : 1), 
Â  Â  Â  Â  beat_value: 4 
Â  Â  });
Â  Â  
Â  Â  voice.addTickables(notes);
Â  Â  new VF.Formatter().joinVoices([voice]).format([voice], width);
Â  Â  voice.draw(ctx, stave);

Â  Â  highlight();
}


function highlight() {
Â  Â  // We only need to query elements within the notation area
Â  Â  document.querySelectorAll('#notation .vf-notehead path').forEach(p => p.style.fill = 'var(--default-note)');
Â  Â  
Â  Â  const targetNoteElement = document.querySelector('#notation [data-i="0"]');
Â  Â  if (!targetNoteElement) return;
Â  Â  
Â  Â  targetNoteElement.querySelectorAll('.vf-notehead path').forEach(p => p.style.fill = 'var(--target-note)');
}

function correctNote() {
Â  Â  const el = document.getElementById('notation');
Â  Â  
Â  Â  // FIX: Apply the transition *before* the transform for a smooth start
Â  Â  el.style.transition = `transform ${ANIMATION_DURATION}ms ease-out`;

Â  Â  // 1. Start the smooth slide animation (only moving the notes container)
Â  Â  el.style.transform = `translateX(-${NOTE_WIDTH}px)`;

Â  Â  setTimeout(() => {
Â  Â  Â  Â  // 2. Update the internal sequence
Â  Â  Â  Â  sequence.shift();
Â  Â  Â  Â  sequence.push(generateItem());
Â  Â  Â  Â  
Â  Â  Â  Â  // 3. Update stats
Â  Â  Â  Â  correct++; streak++; best = Math.max(best, streak);
Â  Â  Â  Â  updateStats();
Â  Â  Â  Â  
Â  Â  Â  Â  // 4. Redraw the scrolling notes (instant reset to position 0)
Â  Â  Â  Â  drawNotes(); 
Â  Â  Â  Â  
Â  Â  }, ANIMATION_DURATION); 
}

function wrongNote() {
Â  Â  const windowEl = document.getElementById('notation-window');
Â  Â  windowEl.classList.add('wrong-flash');
Â  Â  streak = 0;
Â  Â  setTimeout(() => windowEl.classList.remove('wrong-flash'), 300); 
}

function updateStats() {
Â  Â  total++;
Â  Â  document.getElementById('accuracy').innerText =
Â  Â  Â  Â  (total === 0 ? 100 : Math.round((correct / total) * 100)) + '%';
Â  Â  document.getElementById('streak').innerText = streak;
Â  Â  document.getElementById('best').innerText = best;
}

function midiToVex(m) {
Â  Â  // VexFlow prefers standard accidentals on the note name for parsing, 
Â  Â  // but the key signature determines if the accidental is displayed.
Â  Â  const n = ['c','c#','d','d#','e','f','f#','g','g#','a','a#','b'];
Â  Â  const noteName = n[m%12]; 
Â  Â  return `${noteName}/${Math.floor(m/12)-1}`;
}

const pressedKeys = new Set(); 

navigator.requestMIDIAccess().then(m => {
Â  Â  for (let input of m.inputs.values()) {
Â  Â  Â  Â  input.onmidimessage = e => {
Â  Â  Â  Â  Â  Â  const status = e.data[0];
Â  Â  Â  Â  Â  Â  const midiNote = e.data[1];
Â  Â  Â  Â  Â  Â  const velocity = e.data[2];
Â  Â  Â  Â  Â  Â  const playedVex = midiToVex(midiNote);

Â  Â  Â  Â  Â  Â  if (status === 144 && velocity > 0) { // Note On
Â  Â  Â  Â  Â  Â  Â  Â  pressedKeys.add(playedVex);
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  const targetNote = sequence[0];
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  if (chordMode) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Check if *all* target notes are pressed AND no extra notes are pressed
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const allMatch = targetNote.every(note => pressedKeys.has(note)) && (targetNote.length === pressedKeys.size);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (allMatch) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  correctNote();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  pressedKeys.clear(); 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (!targetNote.includes(playedVex)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Wrong note played in a chord
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  wrongNote();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  updateStats(); 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  total++; 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (targetNote.includes(playedVex)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  correctNote();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  wrongNote();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  updateStats();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  } else if (status === 128 || (status === 144 && velocity === 0)) { // Note Off
Â  Â  Â  Â  Â  Â  Â  Â  pressedKeys.delete(playedVex);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  };
Â  Â  }
});

document.getElementById('clefToggle').onchange = e => {
Â  Â  clef = e.target.checked ? 'bass' : 'treble';
Â  Â  start(); 
};
document.getElementById('chordToggle').onchange = e => {
Â  Â  chordMode = e.target.checked;
Â  Â  start();
};
document.getElementById('rhythmToggle').onchange = e => {
Â  Â  rhythmMode = e.target.checked;
Â  Â  start();
};

function exportStats() {
Â  Â  const stats = {
Â  Â  Â  Â  difficulty: difficulty,
Â  Â  Â  Â  scale: currentKey, // Include the selected scale
Â  Â  Â  Â  clef: clef,
Â  Â  Â  Â  chordMode: chordMode,
Â  Â  Â  Â  rhythmMode: rhythmMode,
Â  Â  Â  Â  totalAttempts: total,
Â  Â  Â  Â  totalCorrect: correct,
Â  Â  Â  Â  accuracy: (total === 0 ? 100 : Math.round((correct / total) * 100)) + '%',
Â  Â  Â  Â  currentStreak: streak,
Â  Â  Â  Â  bestStreak: best,
Â  Â  Â  Â  exportTime: new Date().toISOString()
Â  Â  };

Â  Â  const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(stats, null, 2));
Â  Â  const downloadAnchorNode = document.createElement('a');
Â  Â  downloadAnchorNode.setAttribute("href", dataStr);
Â  Â  downloadAnchorNode.setAttribute("download", "MelodyFlow_Stats.json");
Â  Â  document.body.appendChild(downloadAnchorNode);
Â  Â  downloadAnchorNode.click();
Â  Â  downloadAnchorNode.remove();
}

// 1. Populate the dropdown on load
populateScaleDropdown(); 

// 2. Initial start
start();
</script>

</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MelodyFlow v5.3 - Seamless Stave</title>

<script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.2/build/cjs/vexflow.js"></script>

<style>
:root {
Â  Â  --primary: #6750A4;
Â  Â  --surface: #F7F2FA;
Â  Â  --background: #FEF7FF;
Â  Â  --outline: #79747E;
Â  Â  --target-note: #00A96B;
Â  Â  --default-note: #6750A4;
Â  Â  --wrong-flash: #F2B8B5;
}

body {
Â  Â  font-family: 'Segoe UI', Roboto, sans-serif;
Â  Â  background: var(--background);
Â  Â  display: flex;
Â  Â  justify-content: center;
Â  Â  align-items: center;
Â  Â  height: 100vh;
Â  Â  margin: 0;
}

.container {
Â  Â  background: var(--surface);
Â  Â  padding: 32px;
Â  Â  border-radius: 28px;
Â  Â  width: 95%;
Â  Â  max-width: 960px;
Â  Â  text-align: center;
Â  Â  box-shadow: 0 10px 30px rgba(0,0,0,.15);
}

h1 { color: var(--primary); margin-bottom: 10px; }

.controls, .toggles {
Â  Â  display: flex;
Â  Â  justify-content: center;
Â  Â  gap: 10px;
Â  Â  flex-wrap: wrap;
Â  Â  margin-bottom: 12px;
}

button {
Â  Â  border: 1px solid var(--outline);
Â  Â  background: transparent;
Â  Â  padding: 8px 18px;
Â  Â  border-radius: 18px;
Â  Â  cursor: pointer;
}

button.active {
Â  Â  background: var(--primary);
Â  Â  color: white;
}

.toggle {
Â  Â  display: flex;
Â  Â  align-items: center;
Â  Â  gap: 6px;
Â  Â  font-size: 0.85rem;
}

.toggle input {
Â  Â  appearance: none;
Â  Â  width: 34px;
Â  Â  height: 18px;
Â  Â  background: #bbb;
Â  Â  border-radius: 9px;
Â  Â  position: relative;
}

.toggle input:checked { background: var(--primary); }

.toggle input::after {
Â  Â  content: '';
Â  Â  width: 14px;
Â  Â  height: 14px;
Â  Â  background: white;
Â  Â  border-radius: 50%;
Â  Â  position: absolute;
Â  Â  top: 2px;
Â  Â  left: 2px;
Â  Â  transition: transform .2s;
}

.toggle input:checked::after {
Â  Â  transform: translateX(16px);
}

#notation-window {
Â  Â  width: 760px;
Â  Â  height: 180px;
Â  Â  margin: 20px auto;
Â  Â  overflow: hidden;
Â  Â  border-radius: 16px;
Â  Â  border: 2px solid var(--primary);
Â  Â  position: relative;
Â  Â  display: flex;
}

/* New element for the non-moving part */
#fixed-stave {
Â  Â  width: 150px;Â 
Â  Â  height: 180px;
Â  Â  flex-shrink: 0;Â 
Â  Â  position: relative;
Â  Â  z-index: 10;Â 
Â  Â  background-color: var(--surface);Â 
}

/* The element that holds the scrolling notes */
#notation {
Â  Â  /* Use a negative margin to visually overlap the staves and hide the gap */
Â  Â  margin-left: -5px;Â 
Â  Â  width: calc(760px - 150px + 5px); /* Adjusted width to compensate for negative margin */
Â  Â  height: 180px;
Â  Â  position: relative;
Â  Â  /* FIX: The transition will be applied and removed dynamically in JS to prevent "bounce" */
Â  Â  /* Remove the static transition line here */
}


/* Reduced shake animation and targeted to notation area */
.wrong-flash {
Â  Â  animation: shake .3s;
Â  Â  background-color: var(--wrong-flash);Â 
Â  Â  border-color: #E35050 !important;
}

@keyframes shake {
Â  Â  0% { transform: translateX(0); }
Â  Â  25% { transform: translateX(-2px); }
Â  Â  50% { transform: translateX(2px); }
Â  Â  75% { transform: translateX(-2px); }
Â  Â  100% { transform: translateX(0); }
}

.stats {
Â  Â  display: flex;
Â  Â  justify-content: center;
Â  Â  gap: 20px;
Â  Â  font-size: 0.85rem;
Â  Â  margin-top: 15px;
}

/* New styles for dropdown to match button styling */
select#scale-select {
Â  Â  border: 1px solid var(--outline);
Â  Â  background: transparent;
Â  Â  padding: 8px 18px;
Â  Â  border-radius: 18px;
Â  Â  cursor: pointer;
Â  Â  margin-left: 10px;
Â  Â  /* Remove default arrow on some browsers for cleaner look */
Â  Â  appearance: none;
Â  Â  -moz-appearance: none;
Â  Â  -webkit-appearance: none;
Â  Â  background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%2379747E' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
Â  Â  background-repeat: no-repeat;
Â  Â  background-position: right 8px center;
Â  Â  padding-right: 30px; /* Make space for the custom arrow */
}

</style>
</head>

<body>

<div class="container" id="card">
<h1>MelodyFlow</h1>

<div class="controls">
Â  Â  <button id="btn-beginner" class="active" onclick="setDifficulty('Beginner', event)">Beginner</button>
Â  Â  <button id="btn-intermediate" onclick="setDifficulty('Intermediate', event)">Intermediate</button>
Â  Â  <button id="btn-advanced" onclick="setDifficulty('Advanced', event)">Advanced</button>

Â  Â  Â  Â  <select id="scale-select" onchange="setScale(this.value)">
Â  Â  Â  Â  <option value="" disabled>Select Scale...</option>
Â  Â  </select>
</div>

<div class="toggles">
Â  Â  <label class="toggle">Bass Clef <input type="checkbox" id="clefToggle"></label>
Â  Â  <label class="toggle">Chord Mode <input type="checkbox" id="chordToggle"></label>
Â  Â  <label class="toggle">Rhythm Mode <input type="checkbox" id="rhythmToggle"></label>
Â  Â  <button onclick="exportStats()">Export Stats ðŸ“Š</button>
</div>

<div id="notation-window">
Â  Â  <div id="fixed-stave"></div>
Â  Â  <div id="notation"></div>
</div>

<div class="stats">
Â  Â  <div>Accuracy: <span id="accuracy">100%</span></div>
Â  Â  <div>Streak: <span id="streak">0</span></div>
Â  Â  <div>Best: <span id="best">0</span></div>
</div>
</div>

<script>
const VF = Vex.Flow;
const NOTES_VISIBLE = 8;
const NOTE_WIDTH = 100; // Estimated width of a note block for sliding
const FIXED_STAVE_WIDTH = 150; // Must match CSS
const ANIMATION_DURATION = 300; // ms (0.3s)

let difficulty = 'Beginner';
let clef = 'treble';
let chordMode = false;
let rhythmMode = false;
let currentKey = 'C';
let currentScale = null; // New variable to store the currently selected scale

let sequence = [];
let total = 0, correct = 0;
let streak = 0, best = 0;

// All natural notes on the staff (covering a decent range for all difficulties)
const NATURAL_NOTES = [
    'f/3','g/3','a/3','b/3','c/4','d/4','e/4','f/4','g/4','a/4','b/4','c/5','d/5'
];

// Scale Definitions: KeySignature, KeyName (for display), and the notes in the scale (all octaves)
// The key signature is what VexFlow uses (e.g., "C", "G", "Fm", "Bbm")
const ALL_SCALES = [
    // 0 Sharps/Flats (C Major / A Minor)
    { keySig: 'C', name: 'C Major', notes: ['C', 'D', 'E', 'F', 'G', 'A', 'B'] },
    { keySig: 'Am', name: 'A Minor', notes: ['A', 'B', 'C', 'D', 'E', 'F', 'G'] },
    // Clockwise (Sharps)
    { keySig: 'G', name: 'G Major', notes: ['G', 'A', 'B', 'C', 'D', 'E', 'F#'] },
    { keySig: 'Em', name: 'E Minor', notes: ['E', 'F#', 'G', 'A', 'B', 'C', 'D'] },
    { keySig: 'D', name: 'D Major', notes: ['D', 'E', 'F#', 'G', 'A', 'B', 'C#'] },
    { keySig: 'Bm', name: 'B Minor', notes: ['B', 'C#', 'D', 'E', 'F#', 'G', 'A'] },
    { keySig: 'A', name: 'A Major', notes: ['A', 'B', 'C#', 'D', 'E', 'F#', 'G#'] },
    { keySig: 'F#m', name: 'F# Minor', notes: ['F#', 'G#', 'A', 'B', 'C#', 'D', 'E'] },
    { keySig: 'E', name: 'E Major', notes: ['E', 'F#', 'G#', 'A', 'B', 'C#', 'D#'] },
    { keySig: 'C#m', name: 'C# Minor', notes: ['C#', 'D#', 'E', 'F#', 'G#', 'A', 'B'] },
    { keySig: 'B', name: 'B Major', notes: ['B', 'C#', 'D#', 'E', 'F#', 'G#', 'A#'] },
    { keySig: 'G#m', name: 'G# Minor', notes: ['G#', 'A#', 'B', 'C#', 'D#', 'E', 'F#'] },
    { keySig: 'F#', name: 'F# Major', notes: ['F#', 'G#', 'A#', 'B', 'C#', 'D#', 'E#'] },
    { keySig: 'D#m', name: 'D# Minor', notes: ['D#', 'E#', 'F#', 'G#', 'A#', 'B', 'C#'] },
    // Enharmonic equivalent used for simplicity and commonality (Gb Major / Eb Minor)
    { keySig: 'Gf', name: 'Gâ™­ Major', notes: ['Gf', 'Af', 'Bf', 'Cf', 'Df', 'Ef', 'F'] }, // 'Gf' is VexFlow for Gb
    { keySig: 'Efm', name: 'Eâ™­ Minor', notes: ['Ef', 'F', 'Gf', 'Af', 'Bf', 'Cf', 'Df'] }, // 'Efm' is VexFlow for Ebm
    
    // Counter-Clockwise (Flats) - Added for completeness
    { keySig: 'F', name: 'F Major', notes: ['F', 'G', 'A', 'Bf', 'C', 'D', 'E'] },
    { keySig: 'Dm', name: 'D Minor', notes: ['D', 'E', 'F', 'G', 'A', 'Bf', 'C'] },
    { keySig: 'Bf', name: 'Bâ™­ Major', notes: ['Bf', 'C', 'D', 'Ef', 'F', 'G', 'A'] },
    { keySig: 'Gm', name: 'G Minor', notes: ['G', 'A', 'Bf', 'C', 'D', 'Ef', 'F'] },
    { keySig: 'Ef', name: 'Eâ™­ Major', notes: ['Ef', 'F', 'G', 'Af', 'Bf', 'C', 'D'] },
    { keySig: 'Cm', name: 'C Minor', notes: ['C', 'D', 'Ef', 'F', 'G', 'Af', 'Bf'] },
    { keySig: 'Af', name: 'Aâ™­ Major', notes: ['Af', 'Bf', 'C', 'Df', 'Ef', 'F', 'G'] },
    { keySig: 'Fm', name: 'F Minor', notes: ['F', 'G', 'Af', 'Bf', 'C', 'Df', 'Ef'] },
    { keySig: 'Df', name: 'Dâ™­ Major', notes: ['Df', 'Ef', 'F', 'Gf', 'Af', 'Bf', 'C'] },
    { keySig: 'Bfm', name: 'Bâ™­ Minor', notes: ['Bf', 'C', 'Df', 'Ef', 'F', 'Gf', 'Af'] },
];


// Original difficulty ranges are modified to only control the note range (octaves)
const ranges = {
Â  Â  Beginner: {
Â  Â  Â  Â  notes: ['c/4','d/4','e/4','f/4','g/4'] // Smallest range
Â  Â  },
Â  Â  Intermediate: {
Â  Â  Â  Â  notes: ['a/3','b/3','c/4','d/4','e/4','f/4','g/4','a/4','b/4','c/5'] // Wider range
Â  Â  },
Â  Â  Advanced: {
Â  Â  Â  Â  notes: ['f/3','g/3','a/3','b/3','c/4','d/4','e/4','f/4','g/4','a/4','b/4','c/5','d/5'] // Full range
Â  Â  }
};

/**
 * Initializes the scale dropdown with all options.
 */
function initScaleDropdown() {
    const select = document.getElementById('scale-select');
    ALL_SCALES.forEach((scale, index) => {
        const option = document.createElement('option');
        option.value = index; // Use index as value for easy lookup
        option.text = scale.name;
        select.appendChild(option);
    });
    // Set C Major as the initial selected scale
    select.value = 0;
    currentScale = ALL_SCALES[0];
}

/**
 * Set the current scale based on the dropdown selection.
 */
function setScale(scaleIndex) {
    currentScale = ALL_SCALES[parseInt(scaleIndex)];
    currentKey = currentScale.keySig.includes('m') ? currentScale.keySig.slice(0, -1) : currentScale.keySig; // Use base note for `currentKey` or keep full signature
    start();
}


/**
 * Returns a random note that is within the current scale AND the current difficulty note range.
 * This is the core logic change.
 */
function randomNote() {
    if (!currentScale) return 'c/4'; // Default if scale isn't set yet

    const difficultyRange = ranges[difficulty].notes;
    const scaleNotesBase = currentScale.notes.map(n => n.toLowerCase().replace('f', 'b').replace('s', '#')); // Convert for comparison (e.g., 'Gf' -> 'gb')
    
    // Filter the full natural range based on both criteria
    const availableNotes = NATURAL_NOTES.filter(fullNote => {
        // 1. Check if the note is within the difficulty's octave range
        const inRange = difficultyRange.includes(fullNote);
        
        // 2. Check if the note is a member of the selected scale
        const noteName = fullNote.replace(/\/\d/, '').replace(/#/, 's').replace(/b/, 'f'); // Vexflow base name (e.g., 'c/4' -> 'c')
        const inScale = scaleNotesBase.some(scaleNote => fullNote.startsWith(scaleNote));
        
        return inRange && inScale;
    });

    if (availableNotes.length === 0) {
        console.warn("No available notes for the current scale and difficulty range!");
        return difficultyRange[0]; // Fallback
    }

    return availableNotes[Math.floor(Math.random() * availableNotes.length)];
}

function generateItem() {
Â  Â  return chordMode ? [randomNote(), randomNote()] : [randomNote()];
}

function start() {
Â  Â  sequence = [];
Â  Â  for (let i = 0; i < NOTES_VISIBLE; i++) sequence.push(generateItem());
Â  Â Â 
Â  Â  if (currentScale) {
        currentKey = currentScale.keySig; // Use the full VexFlow key signature (e.g., "G", "Fm")
    } else {
        // Fallback or initial state
        currentKey = 'C';
    }
    
Â  Â  drawFixedStave();
Â  Â  drawNotes();
}

/**
Â * Draws the Clef, Key, and Time Signature once in the fixed area.
Â */
function drawFixedStave() {
Â  Â  const el = document.getElementById('fixed-stave');
Â  Â  el.innerHTML = '';
Â  Â Â 
Â  Â  const r = new VF.Renderer(el, VF.Renderer.Backends.SVG);
Â  Â  r.resize(FIXED_STAVE_WIDTH, 180);
Â  Â  const ctx = r.getContext();

Â  Â  // Create a narrow stave for the fixed elements
Â  Â  const stave = new VF.Stave(0, 40, FIXED_STAVE_WIDTH);
Â  Â  stave.addClef(clef)
Â  Â  Â  Â  Â  .addTimeSignature("4/4")
Â  Â  Â  Â  Â  .addKeySignature(currentKey);Â // Use the determined key signature
Â  Â  stave.setContext(ctx).draw();
}

/**
Â * Draws only the notes on the scrolling area.
Â */
function drawNotes() {
Â  Â  const el = document.getElementById('notation');
Â  Â Â 
Â  Â  el.innerHTML = '';
Â  Â  el.style.transform = 'translateX(0)'; // Reset transformation to 0
Â  Â  el.style.transition = 'none'; // FIX: Ensure reset is instantaneous (no bounce)

Â  Â  const noteAreaWidth = 760 - FIXED_STAVE_WIDTH;
Â  Â  const width = NOTES_VISIBLE * NOTE_WIDTH + 50;Â 
Â  Â Â 
Â  Â  const r = new VF.Renderer(el, VF.Renderer.Backends.SVG);
Â  Â  r.resize(width, 180);
Â  Â  const ctx = r.getContext();

Â  Â  // FIX: Start the staff line slightly to the left (e.g., at X=-5)Â 
Â  Â  // to overlap the end of the fixed staff and ensure a continuous line.
Â  Â  const stave = new VF.Stave(-5, 40, width + 5);Â 
Â  Â  stave.setContext(ctx).draw();
Â  Â Â 
Â  Â  const durationType = rhythmMode ? '8' : 'q';
Â  Â Â 
Â  Â  const notes = sequence.map((keys, i) => {
Â  Â  Â  Â  const n = new VF.StaveNote({
Â  Â  Â  Â  Â  Â  keys,
Â  Â  Â  Â  Â  Â  duration: durationType,Â 
Â  Â  Â  Â  Â  Â  clef
Â  Â  Â  Â  });
Â  Â  Â  Â  n.setAttribute('data-i', i);
Â  Â  Â  Â  return n;
Â  Â  });

Â  Â  const voice = new VF.Voice({Â 
Â  Â  Â  Â  num_beats: NOTES_VISIBLE * (rhythmMode ? 0.5 : 1),Â 
Â  Â  Â  Â  beat_value: 4Â 
Â  Â  });
Â  Â Â 
Â  Â  voice.addTickables(notes);
Â  Â  new VF.Formatter().joinVoices([voice]).format([voice], width);
Â  Â  voice.draw(ctx, stave);

Â  Â  highlight();
}


function highlight() {
Â  Â  // We only need to query elements within the notation area
Â  Â  document.querySelectorAll('#notation .vf-notehead path').forEach(p => p.style.fill = 'var(--default-note)');
Â  Â Â 
Â  Â  const targetNoteElement = document.querySelector('#notation [data-i="0"]');
Â  Â  if (!targetNoteElement) return;
Â  Â Â 
Â  Â  targetNoteElement.querySelectorAll('.vf-notehead path').forEach(p => p.style.fill = 'var(--target-note)');
}

function correctNote() {
Â  Â  const el = document.getElementById('notation');
Â  Â Â 
Â  Â  // FIX: Apply the transition *before* the transform for a smooth start
Â  Â  el.style.transition = `transform ${ANIMATION_DURATION}ms ease-out`;

Â  Â  // 1. Start the smooth slide animation (only moving the notes container)
Â  Â  el.style.transform = `translateX(-${NOTE_WIDTH}px)`;

Â  Â  setTimeout(() => {
Â  Â  Â  Â  // 2. Update the internal sequence
Â  Â  Â  Â  sequence.shift();
Â  Â  Â  Â  sequence.push(generateItem());
Â  Â  Â  Â Â 
Â  Â  Â  Â  // 3. Update stats
Â  Â  Â  Â  correct++; streak++; best = Math.max(best, streak);
Â  Â  Â  Â  updateStats();
Â  Â  Â  Â Â 
Â  Â  Â  Â  // 4. Redraw the scrolling notes (instant reset to position 0)
Â  Â  Â  Â  drawNotes();Â 
Â  Â  Â  Â Â 
Â  Â  }, ANIMATION_DURATION);Â 
}

function wrongNote() {
Â  Â  const windowEl = document.getElementById('notation-window');
Â  Â  windowEl.classList.add('wrong-flash');
Â  Â  streak = 0;
Â  Â  setTimeout(() => windowEl.classList.remove('wrong-flash'), 300);Â 
}

function updateStats() {
Â  Â  total++;
Â  Â  document.getElementById('accuracy').innerText =
Â  Â  Â  Â  (total === 0 ? 100 : Math.round((correct / total) * 100)) + '%';
Â  Â  document.getElementById('streak').innerText = streak;
Â  Â  document.getElementById('best').innerText = best;
}

function midiToVex(m) {
Â  Â  const n = ['c','c#','d','d#','e','f','f#','g','g#','a','a#','b'];
Â  Â  return `${n[m%12]}${m%12 === 1 || m%12 === 3 || m%12 === 6 || m%12 === 8 || m%12 === 10 ? '#' : ''}/${Math.floor(m/12)-1}`;
}

const pressedKeys = new Set();Â 

navigator.requestMIDIAccess().then(m => {
Â  Â  for (let input of m.inputs.values()) {
Â  Â  Â  Â  input.onmidimessage = e => {
Â  Â  Â  Â  Â  Â  const status = e.data[0];
Â  Â  Â  Â  Â  Â  const midiNote = e.data[1];
Â  Â  Â  Â  Â  Â  const velocity = e.data[2];
Â  Â  Â  Â  Â  Â  const playedVex = midiToVex(midiNote);

Â  Â  Â  Â  Â  Â  if (status === 144 && velocity > 0) { // Note On
Â  Â  Â  Â  Â  Â  Â  Â  pressedKeys.add(playedVex);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  if (chordMode) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const targetChord = sequence[0];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const allMatch = targetChord.every(note => pressedKeys.has(note)) && (targetChord.length === pressedKeys.size);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (allMatch) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  correctNote();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  pressedKeys.clear();Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (!targetChord.includes(playedVex)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  wrongNote();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  updateStats();Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  total++;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (sequence[0].includes(playedVex)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  correctNote();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  wrongNote();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  updateStats();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  } else if (status === 128 || (status === 144 && velocity === 0)) { // Note Off
Â  Â  Â  Â  Â  Â  Â  Â  pressedKeys.delete(playedVex);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  };
Â  Â  }
});

document.getElementById('clefToggle').onchange = e => {
Â  Â  clef = e.target.checked ? 'bass' : 'treble';
Â  Â  start();Â 
};
document.getElementById('chordToggle').onchange = e => {
Â  Â  chordMode = e.target.checked;
Â  Â  start();
};
document.getElementById('rhythmToggle').onchange = e => {
Â  Â  rhythmMode = e.target.checked;
Â  Â  start();
};

function setDifficulty(d, event) {
Â  Â  difficulty = d;
Â  Â  document.querySelectorAll('.controls button').forEach(b => b.classList.remove('active'));
Â  Â  if(event && event.target) {
Â  Â  Â  Â  event.target.classList.add('active');
Â  Â  }
Â  Â  start();
}

function exportStats() {
Â  Â  const stats = {
Â  Â  Â  Â  difficulty: difficulty,
        scale: currentScale ? currentScale.name : 'C Major (Default)',
Â  Â  Â  Â  clef: clef,
Â  Â  Â  Â  chordMode: chordMode,
Â  Â  Â  Â  rhythmMode: rhythmMode,
Â  Â  Â  Â  totalAttempts: total,
Â  Â  Â  Â  totalCorrect: correct,
Â  Â  Â  Â  accuracy: (total === 0 ? 100 : Math.round((correct / total) * 100)) + '%',
Â  Â  Â  Â  currentStreak: streak,
Â  Â  Â  Â  bestStreak: best,
Â  Â  Â  Â  exportTime: new Date().toISOString()
Â  Â  };

Â  Â  const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(stats, null, 2));
Â  Â  const downloadAnchorNode = document.createElement('a');
Â  Â  downloadAnchorNode.setAttribute("href", dataStr);
Â  Â  downloadAnchorNode.setAttribute("download", "MelodyFlow_Stats.json");
Â  Â  document.body.appendChild(downloadAnchorNode);
Â  Â  downloadAnchorNode.click();
Â  Â  downloadAnchorNode.remove();
}

// Call init functions and then start the app
initScaleDropdown();
start();
</script>

</body>
</html>
